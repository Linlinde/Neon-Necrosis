<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éœ“è™¹åæ­» | å¤œåŸä¼ è¯´</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
        :root { --neon-blue:#00f3ff; --neon-pink:#ff00ff; --neon-green:#00ff41; --neon-yellow:#fcee0a; --neon-red:#ff003c; --neon-purple:#bc13fe; --bg-color:#050510; }
        body { margin:0; overflow:hidden; background-color:var(--bg-color); font-family:'Share Tech Mono',monospace; color:white; user-select:none; }
        #game-container { position:relative; width:100vw; height:100vh; }
        canvas { display:block; }
        .scanlines { position:absolute; top:0; left:0; width:100%; height:100%; background:linear-gradient(to bottom, rgba(18,16,16,0) 50%, rgba(0,0,0,0.2) 50%); background-size:100% 4px; pointer-events:none; z-index:10; }
        .vignette { position:absolute; top:0; left:0; width:100%; height:100%; background:radial-gradient(circle, transparent 60%, rgba(0,0,0,0.9) 100%); pointer-events:none; z-index:10; box-shadow:inset 0 0 100px rgba(0,0,0,0.9); }
        #ui-layer { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:20; display:flex; flex-direction:column; justify-content:space-between; padding:20px; box-sizing:border-box; }
        .top-bar { display:flex; justify-content:space-between; align-items:flex-start; }
        .stats-box { background:rgba(5,5,10,0.8); border:1px solid var(--neon-blue); padding:10px; box-shadow:0 0 15px rgba(0,243,255,0.3); text-shadow:0 0 5px var(--neon-blue); backdrop-filter:blur(4px); border-radius:4px; font-size:1.1rem; min-width: 200px; }
        .status-bars-container { width:300px; text-align:right; }
        .bar-bg { width:100%; height:12px; background:#222; margin-bottom:8px; border:1px solid #444; position:relative; }
        .bar-fill { height:100%; transition:width 0.2s, background-color 0.3s; }
        .xp-bar-container { width: 100%; height: 4px; background: #222; margin-top: 2px; border: 1px solid #444; position: relative; }
        .xp-bar-fill { height: 100%; background: var(--neon-yellow); width: 0%; transition: width 0.2s; box-shadow: 0 0 5px var(--neon-yellow); }
        #hp-bar-fill { background:var(--neon-green); box-shadow:0 0 10px var(--neon-green); }
        #humanity-bar-fill { background:var(--neon-blue); box-shadow:0 0 10px var(--neon-blue); }
        #shield-bar-fill { background:var(--neon-blue); position:absolute; top:0; left:0; height:100%; width:0%; opacity:0.7; box-shadow:0 0 5px cyan; }
        #boss-ui { position:absolute; top:80px; left:50%; transform:translateX(-50%); width:60%; display:none; }
        .boss-name { text-align:center; color:var(--neon-red); font-size:1.5rem; text-shadow:0 0 10px var(--neon-red); margin-bottom:5px; letter-spacing:5px; }
        #boss-bar-fill { background:var(--neon-red); box-shadow:0 0 20px var(--neon-red); }
        .skill-cooldown { width:70px; height:70px; border:2px solid #555; position:absolute; bottom:30px; right:30px; display:flex; flex-direction:column; justify-content:center; align-items:center; background:rgba(0,0,0,0.6); color:#888; transition:all 0.2s; transform:skew(-10deg); overflow:hidden; }
        .skill-cooldown.ready { border-color:var(--neon-green); box-shadow:0 0 20px var(--neon-green); color:var(--neon-green); }
        .skill-overlay { position:absolute; bottom:0; left:0; width:100%; background:rgba(0,0,0,0.8); height:0%; transition:height 0.1s linear; }
        .skill-info { z-index:1; display:flex; flex-direction:column; align-items:center; transform:skew(10deg); }
        #minimap-container { position:absolute; bottom:30px; left:30px; width:160px; height:160px; border:2px solid var(--neon-blue); background:rgba(0,10,0,0.85); border-radius:50%; overflow:hidden; box-shadow:0 0 15px rgba(0,243,255,0.2); z-index:30; }
        #minimap-canvas { width:100%; height:100%; display:block; }
        .glitched-text { animation:glitch 1s linear infinite; }
        @keyframes glitch { 2%,64% { transform:translate(2px,0) skew(0deg); } 4%,60% { transform:translate(-2px,0) skew(0deg); } 62% { transform:translate(0,0) skew(5deg); } }
        .screen { position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(5,5,16,0.95); display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:50; backdrop-filter:blur(8px); pointer-events:auto; }
        .hidden { display:none !important; }
        #pause-menu, #market-screen { padding:40px; align-items: stretch; justify-content: flex-start; }
        .menu-container { display:flex; width:100%; height:90%; max-width:1200px; margin:0 auto; border:1px solid var(--neon-blue); background:rgba(10,10,20,0.95); box-shadow:0 0 30px rgba(0,0,0,0.8); flex-direction: column; }
        .menu-top-row { display: flex; flex: 2; border-bottom: 1px solid #333; }
        .menu-bottom-row { flex: 1; padding: 20px; display: flex; flex-direction: column; overflow: hidden; }
        .menu-col { flex:1; padding:30px; border-right:1px solid #333; display:flex; flex-direction:column; }
        .menu-col:last-child { border-right:none; }
        .menu-header { font-size:1.5rem; color:var(--neon-blue); border-bottom:2px solid var(--neon-blue); padding-bottom:10px; margin-bottom:20px; }
        .info-row { margin-bottom:15px; font-size:0.9rem; line-height:1.4; }
        .key-badge { display:inline-block; border:1px solid #666; padding:2px 6px; border-radius:2px; color:var(--neon-yellow); background:#222; margin-right:5px; }
        .class-grid, .diff-grid { display:grid; gap:20px; margin-top:30px; }
        .class-grid { grid-template-columns:repeat(2,1fr); }
        .diff-grid { grid-template-columns:repeat(4,1fr); gap:15px; }
        .card { border:1px solid #444; padding:20px; width:220px; cursor:pointer; transition:0.3s; background:rgba(20,20,30,0.6); text-align:left; position:relative; overflow:hidden; }
        .card:hover { border-color:var(--neon-green); background:rgba(0,255,65,0.05); transform:scale(1.02); box-shadow:0 0 20px rgba(0,255,65,0.2); }
        button { background:transparent; border:2px solid var(--neon-green); color:var(--neon-green); padding:15px 40px; font-size:1.5rem; font-family:'Share Tech Mono'; cursor:pointer; transition:0.2s; margin-top:20px; box-shadow:0 0 10px var(--neon-green); text-transform: uppercase; }
        button:hover { background:var(--neon-green); color:black; box-shadow:0 0 30px var(--neon-green); }
        #upgrade-container { display:flex; gap:20px; margin-top:20px; flex-wrap:wrap; justify-content:center; max-width:900px; }
        .upgrade-card { background:rgba(10,10,20,0.95); border:1px solid var(--neon-blue); width:220px; padding:20px; cursor:pointer; transition:0.2s; display:flex; flex-direction:column; align-items:center; text-align:center; box-shadow:0 0 10px rgba(0,243,255,0.2); position:relative; overflow: hidden;}
        .upgrade-card:hover { transform:translateY(-10px); box-shadow:0 0 30px var(--neon-blue); border-color:white; background:rgba(20,20,40,1); }
        .upgrade-tag { font-size:0.7rem; padding:2px 6px; border:1px solid currentColor; border-radius:4px; margin-bottom:5px; opacity:0.8; }
        .class-bonus { margin-top:10px; font-size:0.8rem; color:var(--neon-yellow); border-top:1px dashed #444; padding-top:5px; width:100%; font-style:italic; }
        #heat-ui { position:absolute; bottom:120px; left:50%; transform:translateX(-50%); width:300px; text-align:center; pointer-events:none; }
        #heat-bar-container { width:100%; height:16px; background:#111; border:1px solid #555; position:relative; overflow:hidden; transform:skew(-20deg); }
        #heat-bar-fill { height:100%; background:linear-gradient(90deg,var(--neon-yellow),#ff8800); width:0%; box-shadow:0 0 15px var(--neon-yellow); }
        #cool-minigame { width:100%; height:24px; background:#111; border:1px solid white; position:relative; margin-top:8px; display:none; transform:skew(-20deg); }
        #sweet-spot { position:absolute; height:100%; background:rgba(255,255,255,0.9); width:20%; left:40%; }
        #cool-cursor { position:absolute; height:120%; top:-10%; width:6px; background:var(--neon-red); left:0%; }
        .hazard-warning { position:absolute; top:20%; width:100%; text-align:center; font-size:3rem; color:var(--neon-red); background:rgba(0,0,0,0.6); padding:20px; display:none; z-index:40; animation:flash 0.5s infinite; text-shadow:0 0 20px var(--neon-red); }
        @keyframes flash { 0%,100% { opacity:1; } 50% { opacity:0.5; } }
        .wave-progress-text { font-size: 0.8rem; color: #aaa; margin-left: 5px; }
        
        /* Database Styles */
        #database-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 10px; overflow-y: auto; height: 100%; }
        .db-card { border: 1px solid #333; background: #111; padding: 10px; font-size: 0.8rem; color: #888; transition: 0.2s; display: flex; flex-direction: column; }
        .db-card.unlocked { border-color: var(--neon-blue); color: white; background: rgba(0, 243, 255, 0.1); }
        .db-card.unlocked:hover { background: rgba(0, 243, 255, 0.2); transform: translateY(-2px); }
        .db-title { font-weight: bold; margin-bottom: 5px; color: inherit; }
        .db-desc { font-size: 0.7rem; line-height: 1.2; flex: 1; }
        .db-type { font-size: 0.6rem; text-transform: uppercase; margin-bottom: 5px; color: #555; }
        .db-card.unlocked .db-type { color: var(--neon-yellow); }

        /* Market Styles */
        #market-items { display: flex; gap: 20px; justify-content: center; margin-top: 20px; }
        .market-card { background: rgba(10, 20, 10, 0.95); border: 1px solid var(--neon-green); width: 220px; padding: 20px; cursor: pointer; display: flex; flex-direction: column; align-items: center; text-align: center; transition: 0.2s; }
        .market-card:hover { transform: translateY(-5px); box-shadow: 0 0 20px var(--neon-green); border-color: white; }
        .market-card.cursed { border-color: var(--neon-red); background: rgba(30, 10, 10, 0.95); }
        .market-card.cursed:hover { box-shadow: 0 0 20px var(--neon-red); }
        .item-icon { font-size: 2rem; margin-bottom: 10px; }
        .item-price { margin-top: auto; font-weight: bold; color: var(--neon-yellow); }
        .item-cost-hum { font-size: 0.8rem; color: var(--neon-blue); margin-top: 2px; }
        .item-cost-hum.danger { color: var(--neon-red); animation: flash 1s infinite; }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>
    <div class="vignette"></div>
    <div id="hazard-msg" class="hazard-warning">å±é™©ï¼šäº¤é€šè½¨é“å¯åŠ¨</div>
    <div id="ui-layer">
        <div class="top-bar">
            <div class="stats-box">
                <div>æ—¶é—´: <span id="timer" style="color:#fff; font-weight:bold;">00:00</span></div>
                <div>å‡»æ€: <span id="kill-count" style="color:var(--neon-red);">0</span></div>
                <div>é‡‘å¸: <span id="credit-count" style="color:var(--neon-yellow);">0</span> Â¥</div>
                <div>
                    ç­‰çº§: <span id="level" style="color:var(--neon-green);">1</span>
                    <div class="xp-bar-container"><div id="xp-bar-fill" class="xp-bar-fill"></div></div>
                </div>
                <div>
                    æ³¢æ•°: <span id="wave-display" style="color:var(--neon-yellow); font-weight:bold;">1/3</span>
                    <span id="wave-progress" class="wave-progress-text">(0/0)</span>
                </div>
                <div id="difficulty-display" style="font-size:0.8rem; margin-top:5px; font-weight:bold;"></div>
                <div class="biome-indicator">åŒºåŸŸ: <span id="biome-name">åŸå¸‚åºŸå¢Ÿ</span></div>
            </div>
            <div class="status-bars-container stats-box">
                <div class="bar-label"><span>ç”Ÿå‘½ (HP)</span><span id="hp-text" style="color:var(--neon-green)">100/100</span></div>
                <div class="bar-bg">
                    <div id="hp-bar-fill" class="bar-fill" style="width:100%;"></div>
                    <div id="shield-bar-fill"></div>
                </div>
                <div class="bar-label"><span>äººæ€§å€¼</span><span id="humanity-status" style="color:var(--neon-blue)">ç¨³å®š</span></div>
                <div class="bar-bg"><div id="humanity-bar-fill" class="bar-fill" style="width:100%;"></div></div>
            </div>
        </div>
        <div id="boss-ui">
            <div id="boss-name" class="boss-name">é¦–é¢†</div>
            <div class="bar-bg" style="height:20px; border-color:var(--neon-red);"><div id="boss-bar-fill" class="bar-fill" style="width:100%;"></div></div>
        </div>
        <div id="heat-ui">
            <!-- Legacy Heat UI kept hidden, moved to player head -->
            <div id="heat-msg" style="margin-bottom:5px; font-weight:bold; text-shadow:0 0 5px black; letter-spacing:2px;"></div>
            <div id="heat-bar-container"><div id="heat-bar-fill"></div></div>
            <div id="cool-minigame"><div id="sweet-spot"></div><div id="cool-cursor"></div></div>
        </div>
        <div class="skill-cooldown" id="skill-box">
            <div id="skill-cd-overlay" class="skill-overlay"></div>
            <div class="skill-info"><span class="skill-key">SHIFT</span><span id="skill-timer" class="skill-timer">å°±ç»ª</span></div>
        </div>
        <div id="minimap-container"><canvas id="minimap-canvas"></canvas></div>
    </div>

    <!-- Screens -->
    <div id="difficulty-screen" class="screen">
        <h1>éœ“è™¹åæ­»</h1><p style="color:var(--neon-blue);">é€‰æ‹©åè®®éš¾åº¦</p>
        <div class="diff-grid" id="diff-grid"></div>
    </div>
    <div id="start-screen" class="screen hidden">
        <h1>éœ“è™¹åæ­»</h1><p style="color:var(--neon-blue);">é€‰æ‹©ä½ çš„èº«ä»½</p>
        <div class="class-grid" id="class-grid"></div>
        <div style="margin-top:30px; font-size:0.8rem; color:#888;">æ“ä½œè¯´æ˜: [WASD] ç§»åŠ¨ | [ç©ºæ ¼] æ•£çƒ­/å®Œç¾è£…å¡« | [SHIFT] èŒä¸šæŠ€èƒ½ | [ESC] æš‚åœ</div>
        <button onclick="backToDifficulty()" style="font-size:1rem; padding:10px 20px; border-color:#666; color:#aaa;">è¿”å›</button>
    </div>
    <div id="pause-menu" class="screen hidden">
        <h2 style="color:var(--neon-blue); margin-bottom: 10px;">ç³»ç»Ÿæš‚åœ</h2>
        <div class="menu-container">
            <div class="menu-top-row">
                <div class="menu-col">
                    <div class="menu-header">å½“å‰çŠ¶æ€</div>
                    <div class="info-row">èº«ä»½: <b id="menu-class-name" style="color:var(--neon-blue)">æœªçŸ¥</b></div>
                    <div id="stats-display" style="font-size:0.8rem; color:#aaa; display:grid; grid-template-columns:1fr 1fr; gap:5px;"></div>
                    <div class="menu-header" style="margin-top:20px;">å·²å®‰è£…æ¨¡å—</div>
                    <div id="menu-upgrade-list" style="overflow-y:auto; flex:1;"></div>
                </div>
                <div class="menu-col">
                    <div class="menu-header">æ“ä½œæŒ‡å—</div>
                    <div class="info-row"><span class="key-badge">WASD</span> ç§»åŠ¨</div>
                    <div class="info-row"><span class="key-badge">ç©ºæ ¼</span> ä¸»åŠ¨è£…å¡« / æ•£çƒ­</div>
                    <div class="info-row"><span class="key-badge">SHIFT</span> èŒä¸šæŠ€èƒ½</div>
                    <div class="info-row" style="margin-top:auto;"><button class="resume-btn" onclick="togglePause()">ç»§ç»­æ¸¸æˆ</button></div>
                    <div class="info-row"><button class="restart-btn" onclick="restartGame()">é‡æ–°å¯åŠ¨</button></div>
                </div>
            </div>
            <div class="menu-bottom-row">
                <div class="menu-header" style="font-size: 1rem; margin-bottom: 10px;">æ•Œäººå›¾é‰´</div>
                <div id="database-grid"></div>
            </div>
        </div>
    </div>
    <div id="levelup-screen" class="screen hidden">
        <h2 style="color:var(--neon-green);">ç³»ç»Ÿå‡çº§å°±ç»ª</h2>
        <div id="upgrade-container"></div>
    </div>
    <div id="market-screen" class="screen hidden">
        <h2 style="color:var(--neon-green);">é»‘å¸‚äº¤æ˜“</h2>
        <p style="color:#888; margin-bottom: 20px;">ä¾¦æµ‹åˆ°æœªæˆæƒä¿¡å·</p>
        <div class="stats-box" style="margin-bottom: 20px; display: flex; gap: 20px;">
            <div style="color:var(--neon-yellow)">é‡‘å¸: <span id="market-credits">0</span> Â¥</div>
            <div style="color:var(--neon-blue)">äººæ€§å€¼: <span id="market-humanity">100</span></div>
        </div>
        <div id="market-items"></div>
        <div style="margin-top: 30px;">
            <button onclick="refreshMarket()" style="border-color:var(--neon-yellow); color:var(--neon-yellow); font-size: 1rem; padding: 10px 20px;">[R] åˆ·æ–°å•†å“ (<span id="refresh-cost">50</span>Â¥)</button>
            <button onclick="closeMarket()" style="border-color:var(--neon-red); color:var(--neon-red); font-size: 1rem; padding: 10px 20px; margin-left: 20px;">[ESC] ç¦»å¼€</button>
        </div>
    </div>
    <div id="gameover-screen" class="screen hidden">
        <h1 style="color:var(--neon-red)" class="glitched-text">ç”Ÿå‘½ç»ˆç»“</h1>
        <p>ç”Ÿå­˜æ—¶é—´: <span id="final-time"></span></p>
        <p>å‡»æ€æ•°: <span id="final-kills"></span></p>
        <button onclick="restartGame()">é‡æ–°å¯åŠ¨</button>
    </div>
</div>

<script>
    // --- æ€§èƒ½ä¼˜åŒ–ï¼šè·ç¦»è®¡ç®—å¹³æ–¹å‡½æ•° (getDistSq) ---
    // ä½¿ç”¨å¹³æ–¹è·ç¦»é¿å… Math.hypot/Math.sqrtï¼Œæå‡æ€§èƒ½ã€‚
    const getDistSq = (a, b) => (a.x - b.x) ** 2 + (a.y - b.y) ** 2;
    const getDist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const mmCtx = document.getElementById('minimap-canvas').getContext('2d');
    const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    document.getElementById('minimap-canvas').width = 160; document.getElementById('minimap-canvas').height = 160;

    // --- æ€§èƒ½ä¼˜åŒ–ï¼šå¯¹è±¡æ± å®ç° ---
    const POOL_SIZE = 500;
    let bulletsPool = [];
    let particlesPool = [];

    // åˆå§‹åŒ–å¯¹è±¡æ± 
    function initPools() {
        for (let i = 0; i < POOL_SIZE; i++) {
            bulletsPool.push({ active: false });
            particlesPool.push({ active: false });
        }
    }

    // ä»æ± ä¸­è·å–ä¸€ä¸ªå¯ç”¨çš„å¯¹è±¡
    function getFromPool(pool) {
        for (let i = 0; i < pool.length; i++) {
            if (!pool[i].active) {
                pool[i].active = true;
                return pool[i];
            }
        }
        // å¦‚æœæ± æ»¡äº†ï¼Œåˆ›å»ºæ–°å¯¹è±¡ï¼ˆåº”å°½é‡é¿å…ï¼‰
        const newObj = { active: true };
        pool.push(newObj);
        return newObj;
    }

    // é‡Šæ”¾å¯¹è±¡å›æ± 
    function releaseToPool(obj) {
        obj.active = false;
    }
    
    // åˆå§‹åŒ–æ—¶è°ƒç”¨
    initPools();


    const DIFFICULTIES = {
        easy:   { name: "ç®€å•æ¨¡å¼", hp:0.8, dmg:0.8, speed:0.9, spawn:0.8, color:"#00ff41", trainDeath: false },
        normal: { name: "æ ‡å‡†æ¨¡å¼", hp:1.0, dmg:1.0, speed:1.0, spawn:1.0, color:"#00f3ff", trainDeath: false },
        hard:   { name: "æŒ‘æˆ˜æ¨¡å¼", hp:1.5, dmg:1.5, speed:1.2, spawn:1.3, color:"#ff003c", trainDeath: false },
        expert: { name: "åœ°ç‹±æ¨¡å¼", hp:2.5, dmg:2.0, speed:1.4, spawn:1.6, color:"#bc13fe", trainDeath: true }
    };

    const ENEMY_DATA = {
        'hound': { name: 'èµ›åšçŒçŠ¬', desc: 'é«˜é€Ÿç§»åŠ¨å•ä½ï¼Œä¼šå°è¯•ç»•åè¿›è¡Œæ”»å‡»ã€‚', hp: 40, speed: 140, color: '#888', size: 12, xp: 2, credits: 2, ai: 'flank', shape: 'rect' },
        'junkie': { name: 'ç˜¾å›å­', desc: 'å¹³æ—¶ç¼“æ…¢ï¼Œè¡€é‡ä½äº50%æ—¶ç‹‚æš´åŠ é€Ÿã€‚', hp: 50, speed: 50, color: '#00aa00', size: 14, xp: 1, credits: 1, ai: 'berserk', shape: 'circle' },
        'shielder': { name: 'é˜²æš´ç›¾å…µ', desc: 'æ‰‹æŒç›¾ç‰Œï¼Œæ­£é¢æ ¼æŒ¡æ‰€æœ‰ä¼¤å®³ã€‚è¯·ç»•åæ”»å‡»ã€‚', hp: 120, speed: 30, color: '#0033cc', size: 20, xp: 3, credits: 5, ai: 'shield', shape: 'square' },
        'molotov': { name: 'ç‡ƒçƒ§ç“¶æš´å¾’', desc: 'æŠ•æ·ç‡ƒçƒ§ç“¶ï¼Œåˆ¶é€ æŒç»­ä¼¤å®³çš„ç«æµ·ã€‚', hp: 35, speed: 70, color: '#ffff00', size: 14, xp: 2, credits: 3, ai: 'molotov_throw', shape: 'triangle' },
        'drone_sec': { name: 'å®‰å…¨æ— äººæœº', desc: 'æˆç¾¤ç»“é˜Ÿï¼Œå›´ç»•ä½ é£è¡Œå¹¶å°„å‡»ã€‚', hp: 25, speed: 110, color: '#ffffff', size: 10, xp: 1, credits: 2, ai: 'drone_spiral', shape: 'x' },
        'drone_med': { name: 'åŒ»ç–—æ— äººæœº', desc: 'ä¸æ”»å‡»ï¼Œä¸“æ³¨äºæ²»ç–—å—ä¼¤çš„ç²¾é”æ•Œäººã€‚', hp: 30, speed: 100, color: '#00ffaa', size: 12, xp: 2, credits: 3, ai: 'healer', shape: 'cross' },
        'sniper': { name: 'å…¬å¸ç‹™å‡»æ‰‹', desc: 'è¶…è¿œè·ç¦»é”å®šï¼Œçº¢çº¿å˜å®åé€ æˆå·¨é¢ä¼¤å®³ã€‚', hp: 45, speed: 20, color: '#ff0000', size: 14, xp: 3, credits: 10, ai: 'sniper', shape: 'diamond' },
        'barrier': { name: 'åŠ›åœºå±éšœ', desc: 'å±•å¼€åŠ›åœºæŠ¤ç›¾ï¼Œä¿æŠ¤èŒƒå›´å†…çš„å‹å†›ã€‚å‡»ç ´å®ƒï¼', hp: 200, speed: 15, color: '#008888', size: 25, xp: 5, credits: 15, ai: 'barrier', shape: 'hexagon' },
        'bit_eater': { name: 'ä½å…ƒåå™¬è€…', desc: 'éšå½¢å•ä½ï¼Œåªæœ‰åœ¨æ”»å‡»å‰ä¸€åˆ»æ‰ä¼šæ˜¾å½¢ã€‚', hp: 60, speed: 130, color: '#000', size: 15, xp: 3, credits: 4, ai: 'stealth', shape: 'glitch' },
        'replicator': { name: 'å¤åˆ¶è€…', desc: 'è¢«æ‘§æ¯æ—¶ä¼šåˆ†è£‚æˆä¸¤ä¸ªè¾ƒå°çš„ä¸ªä½“ã€‚', hp: 80, speed: 60, color: '#bc13fe', size: 18, xp: 4, credits: 6, ai: 'split', shape: 'poly' },
        'logic_bomb': { name: 'é€»è¾‘ç‚¸å¼¹', desc: 'å†²å‘ä½ å¹¶å¯åŠ¨å€’è®¡æ—¶ï¼Œéšåå¤§èŒƒå›´è‡ªçˆ†ã€‚', hp: 50, speed: 160, color: '#ff003c', size: 16, xp: 2, credits: 5, ai: 'suicide', shape: 'skull' },
        'leech': { name: 'æ•°æ®æ°´è›­', desc: 'å­˜åœ¨æ—¶å¹²æ‰°ç³»ç»Ÿï¼Œä½¿ä½ æ— æ³•è‡ªç„¶æ•£çƒ­æˆ–å†·å´æŠ€èƒ½ã€‚', hp: 100, speed: 30, color: '#004400', size: 20, xp: 5, credits: 8, ai: 'debuff', shape: 'jelly' },
        'boss_tank': { name: 'æœºæ¢°é£Ÿäººé­”', desc: 'è´«æ°‘çªŸéœ¸ä¸»ã€‚', hp: 800, speed: 50, color: '#ff0000', size: 60, xp: 50, credits: 500, ai: 'boss', shape: 'boss' },
        'boss_exec': { name: 'å¤„å†³è€…', desc: 'å…¬å¸ç²¾è‹±æ‰§æ³•å•ä½ã€‚', hp: 1200, speed: 60, color: '#fcee0a', size: 50, xp: 100, credits: 600, ai: 'boss', shape: 'boss' },
        'boss_core': { name: 'ä¸»æœºæ ¸å¿ƒ', desc: 'åŒºåŸŸAIä¸»è„‘ã€‚', hp: 2000, speed: 40, color: '#00ff41', size: 80, xp: 200, credits: 800, ai: 'boss', shape: 'boss' }
    };

    const MARKET_ITEMS = [
        // Type A: Military Implants
        { id: 'sec_heart', name: 'ç¬¬äºŒå¿ƒè„', type: 'A', rarity: 'legendary', cost: 800, hum: 25, desc: 'å¤æ´»: æ­»äº¡æ—¶æ¢å¤50%è¡€é‡å¹¶æ— æ•Œ3ç§’', effect: p => p.stats.revive = true, icon: 'ğŸ«€' },
        { id: 'kiroshi', name: 'æ­§è·¯å¸ä¹‰çœ¼', type: 'A', rarity: 'epic', cost: 500, hum: 15, desc: 'å¼±ç‚¹çœ‹ç ´: æš´å‡»ç‡+10%, æš´å‡»ä¼¤å®³250%', effect: p => { p.stats.critRate += 0.1; p.stats.critDmg = 2.5; }, icon: 'ğŸ‘ï¸' },
        { id: 'gorilla', name: 'å¤§çŒ©çŒ©æ‰‹è‡‚', type: 'A', rarity: 'rare', cost: 400, hum: 20, desc: 'å—åˆ°è¿‘æˆ˜æ”»å‡»æ—¶é‡Šæ”¾éœ‡æ³¢ (CD:5s)', effect: p => p.stats.reactiveArmor = true, icon: 'ğŸ¦¾' },
        { id: 'nano_leech', name: 'çº³ç±³å¸è¡€è™«', type: 'A', rarity: 'epic', cost: 600, hum: 18, desc: 'å¸è¡€: é€ æˆä¼¤å®³çš„3%è½¬åŒ–ä¸ºç”Ÿå‘½', effect: p => p.stats.lifesteal += 0.03, icon: 'ğŸ§¬' },
        { id: 'smart_link', name: 'æ™ºèƒ½è¿æ¥', type: 'A', rarity: 'rare', cost: 350, hum: 10, desc: 'æ‰€æœ‰å­å¼¹è·å¾—è‡ªåŠ¨è¿½è¸ª', effect: p => p.stats.tracking = true, icon: 'ğŸ¯' },
        { id: 'sub_armor', name: 'çš®ä¸‹æŠ¤ç”²', type: 'A', rarity: 'common', cost: 250, hum: 8, desc: 'ç¡¬åŒ–: å›ºå®šå‡ä¼¤ +3', effect: p => p.stats.flatDmgReduc = (p.stats.flatDmgReduc||0) + 3, icon: 'ğŸ›¡ï¸' },

        // Type B: Consumables
        { id: 'immuno', name: 'å…ç–«æŠ‘åˆ¶å‰‚', type: 'B', rarity: 'common', cost: 150, hum: -20, desc: 'ç†æ™ºæ¢å¤: ç«‹å³æ¢å¤ 20 ç‚¹äººæ€§', effect: p => p.humanity = Math.min(100, p.humanity + 20), icon: 'ğŸ’‰' },
        { id: 'battery', name: 'é»‘å¸‚ç”µæ± ', type: 'B', rarity: 'common', cost: 100, hum: 0, desc: 'å……èƒ½: é‡ç½®æŠ€èƒ½ä¸çƒ­é‡', effect: p => { p.skillCd = 0; p.weapon.heat = 0; }, icon: 'âš¡' },
        { id: 'stim', name: 'æˆ˜æ–—å…´å¥‹å‰‚', type: 'B', rarity: 'common', cost: 120, hum: 5, desc: 'çˆ†å‘: 30ç§’å†…ç§»é€Ÿ+40% æ”»é€Ÿ+30%', effect: p => { p.speed *= 1.4; p.weapon.fireRate /= 1.3; setTimeout(()=>{ p.speed/=1.4; p.weapon.fireRate*=1.3; }, 30000); }, icon: 'ğŸ’Š' },
        { id: 'repair', name: 'çº³ç±³ä¿®å¤å‰‚', type: 'B', rarity: 'rare', cost: 200, hum: 0, desc: 'æ²»ç–—: æ¢å¤ 100% ç”Ÿå‘½å€¼', effect: p => p.hp = p.maxHp, icon: 'ğŸ”§' },

        // Type C: Cursed
        { id: 'glass', name: 'ç»ç’ƒå¤§ç‚®', type: 'C', rarity: 'cursed', cost: 50, hum: 40, desc: 'ä¼¤å®³ +200%, æœ€å¤§ç”Ÿå‘½é”å®šä¸º 1', effect: p => { p.weapon.damage *= 3; p.maxHp = 1; p.hp = 1; }, icon: 'ğŸ’€' },
        { id: 'devil', name: 'æ¶é­”å¥‘çº¦', type: 'C', rarity: 'cursed', cost: 0, hum: 50, desc: 'è·å¾— 2000 é‡‘å¸, æ‰£é™¤ 50 äººæ€§', effect: p => p.credits += 2000, icon: 'ğŸ’°' },
        { id: 'ballast', name: 'é‡å‹å‹èˆ±', type: 'C', rarity: 'cursed', cost: 100, hum: 10, desc: 'ä¼¤å®³+50%, æŠ¤ç”²+20, ç§»é€Ÿ-40%', effect: p => { p.weapon.damage *= 1.5; p.stats.flatDmgReduc = (p.stats.flatDmgReduc||0) + 20; p.speed *= 0.6; }, icon: 'ğŸŒ' },
        { id: 'overload', name: 'è¿‡è½½æ ¸å¿ƒ', type: 'C', rarity: 'cursed', cost: 100, hum: 20, desc: 'æ— é™è¿‡çƒ­ä¸å¡å£³, ä½†å°„å‡»æ‰£ 2 HP', effect: p => p.stats.infiniteHeat = true, icon: 'ğŸ”¥' }
    ];

    const CLASSES = {
        solo: { name:"ç‹¬ç‹¼ (Solo)", hpMulti:2.0, speedMulti:0.9, weapon:"shotgun", color:"#ffaa00", skillCd:10, baseStats:{regen:1.0, damage:1.2}, desc:"é«˜è¡€é‡ï¼Œé«˜æŠ¤ç”²ã€‚æŠ€èƒ½: æ€’æ°”å®£æ³„ (å‡»é€€å‘¨å›´æ•Œäºº)" },
        netrunner: { name:"é»‘å®¢ (Netrunner)", hpMulti:0.7, speedMulti:1.0, weapon:"smart_pistol", color:"#bc13fe", skillCd:15, baseStats:{xpRange:2.0, ricochet:1, tracking:true}, desc:"è‡ªåŠ¨ç„å‡†ï¼Œé«˜æ‹¾å–èŒƒå›´ã€‚æŠ€èƒ½: ç³»ç»Ÿå´©æºƒ (å†»ç»“æ‰€æœ‰æ•Œäºº)" },
        samurai: { name:"æ­¦å£« (Samurai)", hpMulti:1.2, speedMulti:1.3, weapon:"monowire", color:"#ff003c", skillCd:8, baseStats:{dodge:0.15, critRate:0.15, critDmg:2.0}, desc:"é«˜æœºåŠ¨ï¼Œè¿‘æˆ˜ä¸“å®¶ã€‚æŠ€èƒ½: æ–¯å®‰å¨æ–¯å¦ (é«˜é€Ÿå†²åˆº)" },
        techie: { name:"æŠ€å¸ˆ (Techie)", hpMulti:1.0, speedMulti:0.9, weapon:"tesla", color:"#00ff41", skillCd:12, baseStats:{heatCapMulti:1.5, areaExplosionChance:0.1}, desc:"æ­¦å™¨é«˜å®¹é”™ã€‚æŠ€èƒ½: éƒ¨ç½²å“¨å…µç‚®å°" }
    };

    const LEVEL_CONFIG = [
        { name:"åŸå¸‚åºŸå¢Ÿ", color:"#080808", grid:"#1a1a1a", mechanic:"debris", waves:[
            {count:15,rate:1.5,types:['hound']},
            {count:25,rate:1.2,types:['hound','junkie'], formation: 'v_shape'},
            {count:40,rate:0.9,types:['junkie','shielder','molotov'], formation: 'encircle'}
        ], boss:'boss_tank' },
        { name:"å…¬å¸å¹¿åœº", color:"#050515", grid:"#101030", mechanic:"traffic", waves:[
            {count:20,rate:1.2,types:['drone_sec']},
            {count:35,rate:1.0,types:['drone_sec','drone_med'], formation: 'line'},
            {count:50,rate:0.7,types:['barrier','sniper','drone_sec'], formation: 'encircle'}
        ], boss:'boss_exec' },
        { name:"æœåŠ¡å™¨å†œåœº", color:"#000800", grid:"#001a00", mechanic:"glitch", waves:[
            {count:30,rate:0.9,types:['bit_eater','leech']},
            {count:45,rate:0.7,types:['bit_eater','replicator'], formation: 'v_shape'},
            {count:60,rate:0.5,types:['logic_bomb','replicator','bit_eater'], formation: 'encircle'}
        ], boss:'boss_core' }
    ];

    const UPGRADE_POOL = [
        { id:'kernel_oc', name:'å†…æ ¸è¶…é¢‘ v1.0', tag:'ä¼¤å®³', color:'#ff003c', cost:5, classes:['all'], desc:'åŸºç¡€ä¼¤å®³ +10%', effect:p=>p.weapon.damage*=1.1 },
        { id:'light_driver', name:'è½»é‡åŒ–é©±åŠ¨', tag:'é€Ÿåº¦', color:'#fcee0a', cost:4, classes:['all'], desc:'ç§»åŠ¨é€Ÿåº¦ +8%', effect:p=>p.speed*=1.08 },
        { id:'magnet_hs', name:'ç£åŠ›æ‹¾å–åè®®', tag:'æ‹¾å–', color:'#bc13fe', cost:3, classes:['all'], desc:'æ‹¾å–èŒƒå›´ +25%', effect:p=>p.stats.xpRange*=1.25 },
        { id:'multi_cool', name:'å¤šçº¿ç¨‹å†·å´', tag:'å†·å´', color:'#00f3ff', cost:6, classes:['all'], desc:'æŠ€èƒ½å†·å´æ—¶é—´ -10%', effect:p=>p.stats.cooldownReduc+=0.1 },
        { id:'firewall', name:'é˜²ç«å¢™è¡¥ä¸', tag:'é˜²å¾¡', color:'#00ff41', cost:6, classes:['all'], desc:'å—åˆ°ä¼¤å®³ -2 (æœ€ä½1)', effect:p=>p.stats.flatDmgReduc=(p.stats.flatDmgReduc||0)+2 },
        { id:'emerg_reboot', name:'ç´§æ€¥é‡å¯å®ˆæŠ¤', tag:'æ¢å¤', color:'#00ff41', cost:8, classes:['all'], desc:'ç«‹å³æ¢å¤ 25% ç”Ÿå‘½ï¼Œæœ€å¤§ç”Ÿå‘½ä¸Šé™ +5%', effect:p=>{p.hp+=p.maxHp*0.25; p.maxHp*=1.05;} },
        // SOLO
        { id:'kinetic_shield', name:'åŠ¨èƒ½æŠ¤ç›¾', tag:'ç‹¬ç‹¼', color:'#ffaa00', cost:10, classes:['solo'], desc:'æ¯ç§»åŠ¨500ç ç”ŸæˆæŠ¤ç›¾æŠµæŒ¡ä¸€æ¬¡ä¼¤å®³', effect:p=>{p.hooks.onMove = (d)=>{ p.stats.shieldCharge = (p.stats.shieldCharge||0)+d; if(p.stats.shieldCharge>500 && !p.shield){p.shield=true; playSound('powerup'); showText("æŠ¤ç›¾å¼€å¯",p.x,p.y-50,'#00f3ff'); p.stats.shieldCharge=0;} }} },
        { id:'bulldozer', name:'æ¨åœŸæœºåè®®', tag:'ç‹¬ç‹¼', color:'#ffaa00', cost:8, classes:['solo'], desc:'å†²åˆºæ’å‡»é€ æˆ300%ä¼¤å®³å¹¶å‡»é£æ•Œäºº', effect:p=>{p.stats.dashDmgMult=3.0; p.stats.dashKnockback=true;} },
        // NETRUNNER
        { id:'logic_bomb', name:'é€»è¾‘ç‚¸å¼¹', tag:'é»‘å®¢', color:'#bc13fe', cost:8, classes:['netrunner'], desc:'æ™ºèƒ½æ­¦å™¨å‡»æ€æ•Œäººäº§ç”Ÿçˆ†ç‚¸', effect:p=>{p.hooks.onKill = (e)=>{ if(p.weapon.type==='smart_pistol') createExplosion(e.x,e.y,20,'#bc13fe'); enemies.forEach(sub=>{if(getDistSq(e,sub)<10000) takeDamage(sub, p.weapon.damage*0.5, false, 'explosion'); }); }} },
        { id:'viral_spread', name:'ç—…æ¯’æ‰©æ•£', tag:'é»‘å®¢', color:'#bc13fe', cost:9, classes:['netrunner'], desc:'è¢«å†»ç»“æ•Œäººæ­»äº¡æ—¶ä¼ æŸ“å†»ç»“æ•ˆæœ', effect:p=>{p.hooks.onKill = (e)=>{ if(e.frozen>0) { let closest=null, md=300; enemies.forEach(n=>{if(n!==e && getDistSq(n,e)<md*md){md=getDist(n,e); closest=n;}}); if(closest){closest.frozen=3; showText("æ‰©æ•£",closest.x,closest.y-20,'#bc13fe');} } }} },
        // SAMURAI
        { id:'flow_state', name:'å¿ƒæµçŠ¶æ€', tag:'æ­¦å£«', color:'#ff003c', cost:7, classes:['samurai'], desc:'å‡»æ€å åŠ ç§»é€Ÿ (æœ€é«˜+20%)', effect:p=>{p.hooks.onKill = ()=>{ p.stats.flowStacks=(p.stats.flowStacks||0)+1; if(p.stats.flowStacks>20) p.stats.flowStacks=20; p.stats.flowTimer=5.0; }} },
        { id:'iai_algo', name:'å±…åˆç®—æ³•', tag:'æ­¦å£«', color:'#ff003c', cost:8, classes:['samurai'], desc:'åœæ‰‹2ç§’åï¼Œä¸‹ä¸€æ¬¡æ”»å‡»å¿…çˆ†ä¸”åŒå€ä¼¤å®³', effect:p=>{p.stats.iaiMode=true;} },
        // TECHIE
        { id:'static_field', name:'é™ç”µåœº', tag:'æŠ€å¸ˆ', color:'#00ff41', cost:7, classes:['techie'], desc:'å‘¨å›´150ç æ•Œäººæ¯ç§’å—ç”µå‡»ä¼¤å®³', effect:p=>{p.stats.staticField=true;} },
        { id:'overload_pulse', name:'è¿‡è½½è„‰å†²', tag:'æŠ€å¸ˆ', color:'#00ff41', cost:9, classes:['techie'], desc:'æ­¦å™¨è¿‡çƒ­æ—¶é‡Šæ”¾å…¨å±éœ‡æ³¢', effect:p=>{p.hooks.onOverheat = ()=>{ createShockwave(p.x,p.y,'#ff003c',800); enemies.forEach(e=>{ takeDamage(e, 50, false, 'explosion'); e.pushX=(e.x-p.x)*5; e.pushY=(e.y-p.y)*5; }); }} }
    ];

    let state = { isRunning:false, paused:false, lastTime:0, timeElapsed:0, kills:0, level:1, xp:0, nextLevelXp:10, width:0, height:0, shake:0, hitStop:0, difficulty:DIFFICULTIES.normal, levelIndex:0, waveIndex:0, waveSpawned:0, waveKilled:0, bossActive:false, spawnTimer:0, upgrades:[], globalTime:0, encounteredEnemies: new Set(), market:{active:false, x:0, y:0, timer:0, interact:0, items:[], refreshCost:50, shieldTimer:0},
        trafficTimer: 15, trafficWarning: 0, obstacles: [], glitchZones: [], trafficLaneY: 0
    };
    const camera = { x:0, y:0, kickX: 0, kickY: 0 };
    const player = { x:0, y:0, speed:180, hp:100, maxHp:100, humanity:100, credits:0, radius:12, color:'#fff', invincible:0, skillCd:0, maxSkillCd:10, angle:0, vx:0, vy:0, isDash:false, dashTimer:0, shield:false, stats:{}, weapon:{}, hooks:{}, lastAttackTime:0, jammed:false };
    
    // --- æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨å¯¹è±¡æ± ä»£æ›¿æ•°ç»„ (bullets, particles) ---
    // ä»…ä¿ç•™ gems, credits, texts, turrets, hazards, enemies æ•°ç»„ç”¨äºåŠ¨æ€å¯¹è±¡ç®¡ç†
    let enemies=[], gems=[], credits=[], texts=[], turrets=[], hazards=[], boss=null;
    const keys = {};

    // å°†åŸä»£ç ä¸­çš„ bullets/particles æ•°ç»„æ“ä½œæ”¹ä¸ºè°ƒç”¨å¯¹è±¡æ± å‡½æ•°
    function createBullet(props) {
        const b = getFromPool(bulletsPool);
        Object.assign(b, props, { active: true });
        return b;
    }

    function createParticle(props) {
        const p = getFromPool(particlesPool);
        Object.assign(p, props, { active: true });
        return p;
    }
    // -----------------------------------------------------------

    const AI_BEHAVIORS = {
        flank: (e, p, dt) => {
            if (!e.state) e.state = 0; 
            const dist = getDist(e, p);
            if (e.state === 0) {
                const angleToPlayer = Math.atan2(p.y - e.y, p.x - e.x);
                if (dist > 150) { e.angle = angleToPlayer + Math.sin(state.globalTime * 2) * 0.5; e.speed = 140; } 
                else { e.state = 1; e.timer = 0.5; e.chargeAngle = angleToPlayer; e.speed = 0; }
            } else if (e.state === 1) {
                e.timer -= dt;
                if (e.timer <= 0) { e.state = 2; e.timer = 0.4; e.speed = 600; e.angle = e.chargeAngle; }
            } else if (e.state === 2) {
                e.timer -= dt;
                if (e.timer <= 0) { e.state = 3; e.timer = 1.0; e.speed = 20; }
            } else if (e.state === 3) {
                e.timer -= dt; e.angle = Math.atan2(p.y - e.y, p.x - e.x);
                if (e.timer <= 0) e.state = 0;
            }
        },
        berserk: (e, p, dt) => {
            e.angle = Math.atan2(p.y - e.y, p.x - e.x);
            if (e.hp < e.maxHp * 0.5) { e.color = '#ff0000'; e.speed = 100; e.pushX *= 0.5; e.pushY *= 0.5; }
        },
        shield: (e, p, dt) => { e.angle = Math.atan2(p.y - e.y, p.x - e.x); },
        molotov_throw: (e, p, dt) => {
            const dist = getDist(e, p);
            if (dist < 300) { e.angle = Math.atan2(e.y - p.y, e.x - p.x); e.speed = 80; } 
            else if (dist > 500) { e.angle = Math.atan2(p.y - e.y, p.x - e.x); e.speed = 80; } 
            else { e.speed = 0; }
            e.timer = (e.timer || 0) + dt;
            if (e.timer > 3.0) {
                // ä½¿ç”¨å¯¹è±¡æ± 
                createBullet({ type: 'molotov_bottle', x: e.x, y: e.y, tx: p.x + (Math.random()-0.5)*50, ty: p.y + (Math.random()-0.5)*50, life: 1.0, color: '#ffaa00', speed: 0 });
                e.timer = 0;
            }
        },
        drone_spiral: (e, p, dt) => {
            if (e.orbitAngle === undefined) { e.orbitAngle = Math.atan2(e.y - p.y, e.x - p.x); e.orbitDist = getDist(e, p); }
            e.orbitDist = Math.max(0, e.orbitDist - 50 * dt); e.orbitAngle += 1.0 * dt;
            let targetX = p.x + Math.cos(e.orbitAngle) * e.orbitDist;
            let targetY = p.y + Math.sin(e.orbitAngle) * e.orbitDist;
            e.angle = Math.atan2(targetY - e.y, targetX - e.x); e.speed = 200; 
            e.timer = (e.timer || 0) + dt;
            if (e.timer > 2.0 && e.orbitDist > 100) {
                // ä½¿ç”¨å¯¹è±¡æ± 
                createBullet({ x: e.x, y: e.y, vx: (p.x - e.x), vy: (p.y - e.y), speed: 350, life: 3, damage: 10, color: '#00f3ff', type: 'tracker_orb', homing: true, target: {x: p.x, y: p.y} });
                e.timer = 0;
            }
            if (getDist(e, p) < 40) e.selfDestruct = true;
        },
        healer: (e, p, dt) => {
            let target = null; enemies.forEach(ally => { if (ally !== e && ally.hp < ally.maxHp) target = ally; });
            if (target) { 
                e.angle = Math.atan2(target.y - e.y, target.x - e.x); 
                target.hp = Math.min(target.maxHp, target.hp + 10*dt); 
                ctx.strokeStyle = '#00ff00'; ctx.beginPath(); ctx.moveTo(e.x, e.y); ctx.lineTo(target.x, target.y); ctx.stroke(); 
            } else { 
                // Fix: Don't just run away. Maintain distance.
                const dist = getDist(e, p);
                if (dist > 500) { e.angle = Math.atan2(p.y - e.y, p.x - e.x); } // Too far, come back
                else if (dist < 300) { e.angle = Math.atan2(p.y - e.y, p.x - e.x) + Math.PI; } // Too close, back off
                else { e.angle = Math.atan2(p.y - e.y, p.x - e.x) + Math.PI / 2; } // Orbit
            }
        },
        sniper: (e, p, dt) => {
            const dist = getDist(e, p); e.timer = (e.timer || 0) + dt;
            if (e.timer < 2.0) { e.angle = Math.atan2(p.y - e.y, p.x - e.x); if (dist < 500) e.speed = -20; else e.speed = 0; } 
            else if (e.timer < 3.0) { e.speed = 0; } 
            else { 
                // ä½¿ç”¨å¯¹è±¡æ± 
                createBullet({ x:e.x, y:e.y, vx:Math.cos(e.angle)*800, vy:Math.sin(e.angle)*800, life:2, damage:30, color:'#ff0000', type:'enemy_beam' }); 
                e.timer = 0; playSound('shoot'); e.pushX -= Math.cos(e.angle) * 20; 
            }
        },
        barrier: (e, p, dt) => { enemies.forEach(ally => { if (ally !== e && getDist(e, ally) < 150) ally.shield = true; }); e.angle = Math.atan2(p.y - e.y, p.x - e.x); },
        stealth: (e, p, dt) => { const dist = getDist(e, p); e.angle = Math.atan2(p.y - e.y, p.x - e.x); if (dist > 200) e.alpha = 0.1; else e.alpha = 1.0; },
        suicide: (e, p, dt) => {
             if (!e.state) e.state = 0; const dist = getDist(e, p);
             if (e.state === 0) { e.angle = Math.atan2(p.y - e.y, p.x - e.x); if (dist < 150) { e.state = 1; e.timer = 0.8; e.speed = 0; } } 
             else if (e.state === 1) { e.timer -= dt; if (e.timer <= 0) { createExplosion(e.x, e.y, 50, '#ff0000'); takeDamage(e, 9999, false, 'suicide'); if (dist < 200 && p.invincible <= 0) { p.hp -= 40; p.invincible = 0.5; /* REMOVED: state.shake = 30; */ showText("çˆ†ç‚¸!", p.x, p.y-50, '#ff0000'); } } }
        },
        debuff: (e, p, dt) => { e.angle = Math.atan2(p.y - e.y, p.x - e.x) + Math.PI; },
        boss: (e, p, dt) => { 
            if (!e.state) e.state = 'chase';
            if (e.state === 'chase') { e.angle = Math.atan2(p.y - e.y, p.x - e.x); e.timer = (e.timer || 0) + dt; if (e.timer > 3.0) { e.state = 'smash_prep'; e.timer = 1.5; e.speed = 0; } } 
            else if (e.state === 'smash_prep') { e.timer -= dt; if (e.timer <= 0) { createShockwave(e.x, e.y, '#ff0000', 300); if (getDist(e, p) < 300 && p.invincible <= 0) { p.hp -= 30; p.invincible = 1.0; /* REMOVED: state.shake = 40; */ showText("é‡å‡»!", p.x, p.y-50, '#ff0000'); } e.state = 'chase'; e.timer = 0; e.speed = e.id === 'boss_tank' ? 50 : 60; } }
        },
        default: (e, p, dt) => { e.angle = Math.atan2(p.y - e.y, p.x - e.x); }
    };

    function resize() { canvas.width=state.width=window.innerWidth; canvas.height=state.height=window.innerHeight; }
    window.addEventListener('resize', resize); resize();
    window.addEventListener('keydown', e=>{ keys[e.code]=true; if(e.code==='Escape'&&state.isRunning) togglePause(); if(state.isRunning&&!state.paused){ if(e.code==='Space') handleCooling(); if(e.code==='ShiftLeft') useSkill(); if(e.code==='KeyR' && document.getElementById('market-screen').style.display!=='none') refreshMarket(); } });
    window.addEventListener('keyup', e=>keys[e.code]=false);

    function initUI() {
        const dGrid = document.getElementById('diff-grid'); dGrid.innerHTML='';
        Object.keys(DIFFICULTIES).forEach(k => {
            const d = DIFFICULTIES[k];
            dGrid.innerHTML += `<div class="diff-card" style="border-color:${d.color}" onclick="selectDifficulty('${k}')"><div class="diff-title" style="color:${d.color}">${d.name}</div><div class="diff-stats">ç”Ÿå‘½:${d.hp*100}% ä¼¤å®³:${d.dmg*100}%<br>é€Ÿåº¦:${d.speed*100}% æ•°é‡:${d.spawn*100}%<br>${d.trainDeath?'<span style="color:red">è½¨é“è‡´æ­»</span>':''}</div></div>`;
        });
        const cGrid = document.getElementById('class-grid'); cGrid.innerHTML='';
        Object.keys(CLASSES).forEach(k => {
            const c = CLASSES[k];
            cGrid.innerHTML += `<div class="class-card" onclick="selectClass('${k}')"><div class="class-title" style="color:var(--neon-blue)">${c.name}</div><div class="class-desc">${c.desc}</div></div>`;
        });
        document.getElementById('difficulty-screen').classList.remove('hidden');
    }

    function selectDifficulty(k) {
        state.difficulty = DIFFICULTIES[k];
        document.getElementById('difficulty-display').innerText = `éš¾åº¦: ${state.difficulty.name}`;
        document.getElementById('difficulty-display').style.color = state.difficulty.color;
        document.getElementById('difficulty-screen').classList.add('hidden');
        document.getElementById('start-screen').classList.remove('hidden');
    }
    function backToDifficulty() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('difficulty-screen').classList.remove('hidden'); }

    function selectClass(id) {
        const c = CLASSES[id]; player.classId=id; player.maxHp=100*c.hpMulti; player.hp=player.maxHp; player.baseSpeed=180*c.speedMulti; player.speed=player.baseSpeed; player.color=c.color; player.maxSkillCd=c.skillCd;
        player.stats={lifesteal:0, regen:0, dodge:0, critRate:0.05, critDmg:1.5, xpRange:1, xpBonus:1, penetration:0, ricochet:0, heatCapMulti:1, areaExplosionChance:0, areaExplosionDmgMult:0.5, areaExplosionRadius:100, cooldownReduc:0, tracking:false, ...c.baseStats};
        player.hooks={}; player.shield=false; player.credits = 0;
        setupWeapon(c.weapon);
        document.getElementById('menu-class-name').innerText = c.name;
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('ui-layer').classList.remove('hidden');
        initGame();
        state.isRunning=true; state.lastTime=performance.now();
        requestAnimationFrame(gameLoop);
    }

    function setupWeapon(t) {
        player.weapon = {type:t, heat:0, maxHeat:100, cooldown:0, isOverheated:false, isVenting:false, ventProgress:0, ventSpeed:1.5, spread:0.1, count:1, overclockTimer:0, jamTimer: 0, isInSweetSpot: false, wasInSpot: false, lastShotTime: 0, buffs: {}, anim: {timer: 0}};
        const w = player.weapon;
        if(t==='smart_pistol') { w.damage=15; w.fireRate=0.25; w.range=450; w.projectileSpeed=500; w.spread=0.2; }
        else if(t==='shotgun') { w.damage=10; w.fireRate=0.8; w.range=350; w.count=5; w.spread=0.5; w.projectileSpeed=600; }
        else if(t==='monowire') { w.damage=35; w.fireRate=0.1; w.range=90; }
        else if(t==='tesla') { w.damage=8; w.fireRate=0.15; w.range=350; }
    }

    function initGame() {
        // ä½¿ç”¨å¯¹è±¡æ± ï¼Œæ¸…ç©ºåŠ¨æ€å¯¹è±¡æ•°ç»„
        bulletsPool.forEach(b => releaseToPool(b));
        particlesPool.forEach(p => releaseToPool(p));
        enemies=[]; gems=[]; credits=[]; texts=[]; turrets=[]; hazards=[]; boss=null;
        
        state.timeElapsed=0; state.kills=0; state.level=1; state.xp=0; state.nextLevelXp=10; state.hitStop=0;
        state.levelIndex=0; state.waveIndex=0; state.waveSpawned=0; state.waveKilled=0; state.bossActive=false; state.spawnTimer=0;
        state.upgrades=[]; player.x=0; player.y=0; player.humanity=100; player.skillCd=0; player.lastAttackTime=0; player.credits = 0;
        state.encounteredEnemies = new Set();
        state.market = {active: false, x: 0, y: 0, timer: 0, interact: 0, items: [], refreshCost: 50, shieldTimer: 0};
        initLevel(0);
        document.getElementById('menu-upgrade-list').innerHTML='<div style="text-align:center;color:#666">æ— </div>';
        document.getElementById('boss-ui').style.display='none';
    }

    function initLevel(idx) {
        state.levelIndex = idx;
        const lvl = LEVEL_CONFIG[Math.min(idx, LEVEL_CONFIG.length-1)];
        state.trafficTimer = 15; state.trafficWarning = 0; state.obstacles = []; state.glitchZones = []; state.trafficLaneY = 0; hazards = [];
        if (lvl.mechanic === 'debris') {
            for(let i=0; i<15; i++) {
                let ox, oy, dist;
                do { ox = (Math.random() - 0.5) * state.width * 2; oy = (Math.random() - 0.5) * state.height * 2; dist = Math.hypot(ox, oy); } while(dist < 300);
                state.obstacles.push({ x: ox, y: oy, w: 60 + Math.random() * 80, h: 60 + Math.random() * 80, color: '#444444' });
            }
        }
        if (lvl.mechanic === 'glitch') {
            for(let i=0; i<4; i++) { state.glitchZones.push({ x: (Math.random() - 0.5) * 1000, y: (Math.random() - 0.5) * 1000, w: 250, h: 250, vx: (Math.random() - 0.5) * 50, vy: (Math.random() - 0.5) * 50 }); }
        }
    }

    function spawnEnemyGroup(types, count, formation) {
        if (!formation || formation === 'random') { for(let i=0; i<count; i++) spawnEnemy(types); return; }
        const type = types[Math.floor(Math.random()*types.length)]; const data = ENEMY_DATA[type]; if (!state.encounteredEnemies.has(type)) state.encounteredEnemies.add(type);
        const dist = Math.max(state.width, state.height) * 0.8; const angle = Math.random() * Math.PI * 2;
        for(let i=0; i<count; i++) {
            let ex = 0, ey = 0;
            if (formation === 'v_shape') { const offsetAngle = (i % 2 === 0 ? 1 : -1) * Math.ceil(i/2) * 0.2; const offsetDist = Math.ceil(i/2) * 40; ex = player.x + Math.cos(angle + offsetAngle) * (dist + offsetDist); ey = player.y + Math.sin(angle + offsetAngle) * (dist + offsetDist); } 
            else if (formation === 'line') { const lineAngle = angle + Math.PI/2; const spacing = 50; const offset = (i - count/2) * spacing; ex = player.x + Math.cos(angle) * dist + Math.cos(lineAngle) * offset; ey = player.y + Math.sin(angle) * dist + Math.sin(lineAngle) * offset; } 
            else if (formation === 'encircle') { const step = (Math.PI * 2) / count; ex = player.x + Math.cos(i * step) * dist; ey = player.y + Math.sin(i * step) * dist; }
            const scale = 1 + (state.levelIndex*0.5);
            enemies.push({ id: type, x: ex, y: ey, hp:data.hp*scale*state.difficulty.hp, maxHp:data.hp*scale*state.difficulty.hp, speed:data.speed*state.difficulty.speed, color:data.color, size:data.size, xp:data.xp, credits: data.credits, ai:data.ai, shape:data.shape, pushX:0, pushY:0, frozen:0, angle:0, scale: 0.1, state: 0, timer: 0, shield: (data.ai === 'shielder' || data.ai === 'barrier') });
        }
    }

    function spawnEnemy(types) {
        const a = Math.random()*Math.PI*2; const d = Math.max(state.width,state.height)*0.8;
        const type = types[Math.floor(Math.random()*types.length)]; const data = ENEMY_DATA[type]; if (!state.encounteredEnemies.has(type)) state.encounteredEnemies.add(type);
        const scale = 1 + (state.levelIndex*0.5);
        enemies.push({ id: type, x:player.x+Math.cos(a)*d, y:player.y+Math.sin(a)*d, hp:data.hp*scale*state.difficulty.hp, maxHp:data.hp*scale*state.difficulty.hp, speed:data.speed*state.difficulty.speed, color:data.color, size:data.size, xp:data.xp, credits: data.credits, ai:data.ai, shape:data.shape, pushX:0, pushY:0, frozen:0, angle:0, scale: 0.1, state: 0, timer: 0, shield: (data.ai === 'shielder' || data.ai === 'barrier') });
    }

    function spawnBoss(bossKey) {
        state.bossActive = true; const a = Math.random()*Math.PI*2; const d = 600; const data = ENEMY_DATA[bossKey]; const hp = data.hp * state.difficulty.hp; if (!state.encounteredEnemies.has(bossKey)) state.encounteredEnemies.add(bossKey);
        boss = { id: bossKey, x:player.x+Math.cos(a)*d, y:player.y+Math.sin(a)*d, type:'boss', hp:hp, maxHp:hp, speed:data.speed*state.difficulty.speed, size:data.size, color:data.color, name:data.name, credits: data.credits, pushX:0, pushY:0, frozen:0, angle:0, isBoss:true, ai:'boss', shape:'boss', scale: 0.1 };
        enemies.push(boss);
        const bui = document.getElementById('boss-ui'); bui.style.display='block'; document.getElementById('boss-name').innerText=boss.name; document.getElementById('boss-name').style.color=boss.color; document.getElementById('boss-bar-fill').style.backgroundColor=boss.color;
        showText("é¦–é¢†å‡ºç°", player.x, player.y-150, '#ff0000'); playSound('overheat');
    }

    function killEnemy(e) {
        state.kills++; if (!state.bossActive) state.waveKilled++; if(player.hooks.onKill) player.hooks.onKill(e);
        if (player.classId === 'samurai' && player.weapon.buffs.executionerTimer > 0) { player.skillCd = 0; showText("æŠ€èƒ½åˆ·æ–°", player.x, player.y-80, '#00ff41'); }
        if (e.ai === 'split' && e.size > 10) { for(let i=0; i<2; i++) { enemies.push({ ...e, hp: e.maxHp*0.6, maxHp: e.maxHp*0.6, size: e.size*0.7, speed: e.speed*1.2, x: e.x + (Math.random()-0.5)*20, y: e.y + (Math.random()-0.5)*20, scale: 1.0, ai: 'split_child' }); } }
        if (e.isBoss) {
            boss = null; state.bossActive = false; document.getElementById('boss-ui').style.display = 'none'; createExplosion(e.x, e.y, 50, e.color); showText("é¦–é¢†å‡»è´¥", player.x, player.y - 100, '#00ff41');
            const nextIdx = state.levelIndex + 1; if (nextIdx < LEVEL_CONFIG.length) { initLevel(nextIdx); showText("åŒºåŸŸå®Œæˆ - å·²æ²»ç–—", player.x, player.y - 150, '#fff'); } else { state.levelIndex = 0; initLevel(0); showText("å¾ªç¯å¼€å§‹", player.x, player.y - 150, '#fff'); }
            state.waveIndex = 0; state.waveSpawned = 0; state.waveKilled = 0; player.hp = player.maxHp; spawnMarket();
        }
        gems.push({ x: e.x, y: e.y, val: e.xp }); if (Math.random() < 0.2 || e.isBoss) credits.push({ x: e.x, y: e.y, val: e.credits }); createExplosion(e.x, e.y, 15, e.color);
    }

    function takeDamage(e, amt, crit, source) {
        if(e.hp <= 0) return;
        if (e.shield && e.ai === 'shielder' && source !== 'dragon') { 
            const angleToPlayer = Math.atan2(player.y - e.y, player.x - e.x); 
            const angleDiff = Math.abs(normalizeAngle(angleToPlayer - e.angle)); 
            if (angleDiff < Math.PI/2) { showText("æ ¼æŒ¡", e.x, e.y - 20, '#00f3ff', 12); return; } 
        }
        e.hp -= amt; 
        showText(Math.floor(amt), e.x, e.y, crit?'#fcee0a':'white', crit?24:16); 
        e.scale = 1.3; 
        if (crit || e.hp <= 0) state.hitStop = 0.08;
        
        if (source === 'weapon' && player.stats.lifesteal > 0 && player.hp < player.maxHp) { 
            const heal = amt * player.stats.lifesteal * (player.stats.healEff || 1); 
            player.hp = Math.min(player.maxHp, player.hp + heal); 
        }
        
        if(source === 'weapon' && player.stats.areaExplosionChance>0 && Math.random()<player.stats.areaExplosionChance) { 
            const r = player.stats.areaExplosionRadius; 
            createShockwave(e.x, e.y, '#ff8800', r); 
            state.shake=5; 
            enemies.forEach(sub=>{ 
                // --- ä¼˜åŒ–ç‚¹ï¼šä½¿ç”¨ getDistSq è¿›è¡ŒèŒƒå›´æ£€æŸ¥ ---
                if(sub!==e && getDistSq(sub,e)<r*r) { 
                    sub.pushX += (sub.x-e.x)*2; sub.pushY += (sub.y-e.y)*2; 
                    takeDamage(sub, amt*player.stats.areaExplosionDmgMult, false, 'explosion'); 
                }
            }); 
        }
        if(e.hp<=0) killEnemy(e);
    }

    function fireTesla(target, dmg, idx, isCrit) {
        let list = [target]; let curr = target; takeDamage(target, dmg, isCrit, 'tesla');
        for(let k=0; k<3; k++) {
            let next = null; let minDistSq = 200 * 200; // ä½¿ç”¨å¹³æ–¹è·ç¦»
            enemies.forEach(e => { 
                // --- ä¼˜åŒ–ç‚¹ï¼šä½¿ç”¨ getDistSq è¿›è¡Œè·ç¦»æ£€æŸ¥ ---
                if(!list.includes(e) && getDistSq(curr, e) < minDistSq) { 
                    minDistSq = getDistSq(curr, e); // å¿…é¡»æ˜¯å¹³æ–¹
                    next = e; 
                } 
            });
            if(next) { 
                list.push(next); 
                takeDamage(next, dmg * 0.6, false, 'tesla'); 
                // ä½¿ç”¨å¯¹è±¡æ± 
                createParticle({type:'lightning', chain:[{x:curr.x, y:curr.y}, {x:next.x, y:next.y}], life:0.15, color:'#00f3ff', size:2}); 
                curr = next; 
            } else break;
        }
        // ä½¿ç”¨å¯¹è±¡æ± 
        createParticle({type:'lightning', chain:[{x:player.x, y:player.y}, {x:target.x, y:target.y}], life:0.15, color:'#00f3ff', size:2});
    }

    function normalizeAngle(angle) { while (angle > Math.PI) angle -= Math.PI * 2; while (angle < -Math.PI) angle += Math.PI * 2; return angle; }

    function updateHazards(dt, lvl) {
        const lvlCfg = LEVEL_CONFIG[Math.min(state.levelIndex, LEVEL_CONFIG.length-1)];

        if(lvlCfg.mechanic === 'traffic') {
            state.trafficTimer -= dt;
            if(state.trafficTimer <= 0) {
                state.trafficTimer = 18; state.trafficWarning = 3.0; state.trafficLaneY = player.y; playSound('overheat'); document.getElementById('hazard-msg').style.display='block';
            }
            if(state.trafficWarning > 0) {
                state.trafficWarning -= dt;
                if(state.trafficWarning <= 0) {
                    hazards.push({type:'train', x:player.x-2000, y:state.trafficLaneY, w:4000, h:120, vx:3000, life:2});
                    document.getElementById('hazard-msg').style.display='none'; /* REMOVED: state.shake = 20; */
                }
            }
        }

        if(lvlCfg.mechanic === 'glitch') {
            for(let i=0; i<4; i++) { state.glitchZones.push({ x: (Math.random() - 0.5) * 1000, y: (Math.random() - 0.5) * 1000, w: 250, h: 250, vx: (Math.random() - 0.5) * 50, vy: (Math.random() - 0.5) * 50 }); }
        } else { player.inGlitchZone = false; }

        if (lvl.hazard === 'steam' && Math.random()<0.01) {
            hazards.push({type:'steam', x:player.x+(Math.random()-0.5)*800, y:player.y+(Math.random()-0.5)*600, radius:120, life:5});
        }

        for(let i=hazards.length-1; i>=0; i--) {
            const h = hazards[i]; h.life-=dt;
            if(h.type==='train') {
                h.x+=h.vx*dt;
                enemies.forEach(e=>{ if(Math.abs(e.x-h.x)<h.w/2 && Math.abs(e.y-h.y)<h.h/2) { takeDamage(e, 99999, true, 'hazard'); createExplosion(e.x, e.y, 10, '#ff0000'); } });
                // --- ä¼˜åŒ–ç‚¹ï¼šä½¿ç”¨ getDistSq è¿›è¡Œè·ç¦»æ£€æŸ¥ ---
                const distSqToPlayer = getDistSq(player, h);
                const trainRadiusSq = (h.w/2)**2 + (h.h/2)**2; // ä¼°ç®—ä¸€ä¸ªç¢°æ’èŒƒå›´
                if(distSqToPlayer < trainRadiusSq && player.invincible<=0) {
                    if(player.shield) { player.shield=false; showText("æŠ¤ç›¾ç ´ç¢",player.x,player.y-50,'#00f3ff'); }
                    else { player.hp-=50; player.invincible=1.5; /* REMOVED: state.shake=50; */ playSound('hit'); showText("è‡´å‘½ä¸€å‡»!",player.x,player.y-50,'#ff003c'); if(player.hp<=0) gameOver(); }
                }
            } else if(h.type==='steam') { if(getDist(player,h)<h.radius) player.speed=player.baseSpeed*0.5; }
            else if(h.type==='fire') {
                const fireRadiusSq = h.radius * h.radius;
                if (getDistSq(player, h) < fireRadiusSq && player.invincible <= 0) {
                    if (player.shield) { player.shield=false; showText("æŠ¤ç›¾ç ´ç¢",player.x,player.y-50,'#00f3ff'); }
                    else { player.hp -= 15 * dt; if(player.hp<=0) gameOver(); }
                }
                enemies.forEach(e => { if (getDistSq(e, h) < fireRadiusSq) { takeDamage(e, 10 * dt, false, 'fire'); } });
            }
            if(h.life<=0) hazards.splice(i,1);
        }
    }

    function spawnMarket() {
        const angle = Math.random() * Math.PI * 2; const dist = 500;
        state.market.x = player.x + Math.cos(angle) * dist; state.market.y = player.y + Math.sin(angle) * dist;
        state.market.active = true; state.market.timer = 30; state.market.interact = 0; state.market.shieldTimer = 10; 
        createShockwave(state.market.x, state.market.y, '#00ff41', 400);
        enemies.forEach(e => { 
            // --- ä¼˜åŒ–ç‚¹ï¼šä½¿ç”¨ getDistSq è¿›è¡Œè·ç¦»æ£€æŸ¥ ---
            if(getDistSq(e, state.market) < 400*400) { 
                e.pushX = (e.x - state.market.x) * 5; e.pushY = (e.y - state.market.y) * 5; 
                takeDamage(e, 20, false, 'market_landing'); 
            } 
        });
        showText("é»‘å¸‚ä¸Šçº¿ - å®‰å…¨åŒº", state.market.x, state.market.y - 100, '#00ff41'); playSound('powerup');
    }

    function openMarket() { state.paused = true; generateMarketItems(false); updateMarketUI(); document.getElementById('market-screen').classList.remove('hidden'); }

    function generateMarketItems(isRefresh) {
        state.market.items = []; const pool = MARKET_ITEMS; const inflation = 1 + (state.levelIndex * 0.5) + (state.waveIndex * 0.1);
        for(let i=0; i<4; i++) {
            let valid = false; let item = null; let attempts = 0;
            while(!valid && attempts < 10) {
                item = pool[Math.floor(Math.random() * pool.length)];
                if (isRefresh) { if (item.rarity === 'common' && Math.random() < 0.5) { attempts++; continue; } }
                valid = true;
            }
            const actualCost = Math.floor(item.cost * inflation); state.market.items.push({...item, actualCost: actualCost});
        }
    }

    function updateMarketUI() {
        document.getElementById('market-credits').innerText = player.credits; document.getElementById('market-humanity').innerText = player.humanity;
        document.getElementById('refresh-cost').innerText = state.market.refreshCost;
        const container = document.getElementById('market-items'); container.innerHTML = '';
        state.market.items.forEach((item, index) => {
            const div = document.createElement('div'); div.className = `market-card ${item.type === 'C' ? 'cursed' : ''}`;
            const canAfford = player.credits >= item.actualCost; const canBear = player.humanity > item.hum || item.hum <= 0;
            div.innerHTML = `<div class="item-icon">${item.icon}</div><div style="font-weight:bold; color:${item.type==='C'?'var(--neon-red)':'var(--neon-blue)'}">${item.name}</div><div style="font-size:0.8rem; color:#aaa; margin:5px 0;">${item.desc}</div><div class="item-price" style="color:${canAfford?'var(--neon-yellow)':'var(--neon-red)'}">${item.actualCost} Â¥</div><div class="item-cost-hum ${(!canBear || (player.humanity-item.hum < 20 && item.hum > 0)) ? 'danger' : ''}">${item.hum > 0 ? 'æ‰£é™¤ ' + item.hum : 'æ¢å¤ ' + Math.abs(item.hum)} äººæ€§</div>`;
            div.onclick = () => buyItem(item, index); container.appendChild(div);
        });
    }

    function buyItem(item, index) {
        if (player.credits >= item.actualCost) {
            player.credits -= item.actualCost; player.humanity -= item.hum; if(player.humanity > 100) player.humanity = 100;
            item.effect(player); state.market.items.splice(index, 1); playSound('powerup'); updateMarketUI(); updateUpgradeList();
        } else { playSound('jam'); showText("é‡‘å¸ä¸è¶³", player.x, player.y - 40, '#ff003c'); }
    }

    function refreshMarket() {
        if (player.credits >= state.market.refreshCost) {
            player.credits -= state.market.refreshCost; state.market.refreshCost += 25; 
            generateMarketItems(true); updateMarketUI(); playSound('powerup');
        } else { playSound('jam'); showText("é‡‘å¸ä¸è¶³", player.x, player.y - 40, '#ff003c'); }
    }

    function closeMarket() { document.getElementById('market-screen').classList.add('hidden'); state.paused = false; state.market.active = false; state.lastTime = performance.now(); requestAnimationFrame(gameLoop); }

    function updateDatabaseUI() {
        const db = document.getElementById('database-grid'); db.innerHTML = '';
        Object.keys(ENEMY_DATA).forEach(key => {
            const e = ENEMY_DATA[key]; const unlocked = state.encounteredEnemies.has(key);
            const div = document.createElement('div'); div.className = `db-card ${unlocked?'unlocked':''}`;
            if (unlocked) { div.innerHTML = `<div class="db-type">${e.ai}</div><div class="db-title">${e.name}</div><div class="db-desc">${e.desc}</div>`; } 
            else { div.innerHTML = `<div class="db-title">???</div><div class="db-desc">é­é‡åè§£é”</div>`; }
            db.appendChild(div);
        });
    }

    function togglePause() {
        if(document.getElementById('market-screen').classList.contains('hidden') === false) { closeMarket(); return; }
        state.paused = !state.paused; const el = document.getElementById('pause-menu');
        if(state.paused) {
            document.getElementById('stats-display').innerHTML=`<div>ä¼¤å®³:${Math.round(player.weapon.damage)}</div><div>ç”Ÿå‘½:${Math.round(player.hp)}/${Math.round(player.maxHp)}</div><div>æš´å‡»:${Math.round(player.stats.critRate*100)}%</div><div>é—ªé¿:${Math.round(player.stats.dodge*100)}%</div>`;
            updateUpgradeList(); updateDatabaseUI(); el.classList.remove('hidden');
        } else { el.classList.add('hidden'); state.lastTime=performance.now(); requestAnimationFrame(gameLoop); }
    }
    function restartGame() { location.reload(); }

    function handleCooling() {
        if (player.stats.infiniteHeat || player.inGlitchZone) { return; }
        const w = player.weapon;
        if (w.jamTimer > 0) { playSound('jam'); showText("å¡å£³", player.x, player.y - 40, '#ff003c'); return; }
        if (!w.isVenting && w.heat>0 && !w.isOverheated) { 
            w.isVenting=true; w.ventProgress=0; 
            const heatPct = w.heat / (w.maxHeat * (player.stats.heatCapMulti || 1));
            w.sweetSpotWidth = Math.max(0.05, 0.3 - (heatPct * 0.25)); w.sweetSpotStart = 0.2 + Math.random() * (0.8 - w.sweetSpotWidth - 0.2); w.wasInSpot=false;
        } else if (w.isVenting) {
            if (w.ventProgress>=w.sweetSpotStart && w.ventProgress<=(w.sweetSpotStart+w.sweetSpotWidth)) {
                w.heat=0; w.isVenting=false; w.overclockTimer=5; playSound('powerup'); createExplosion(player.x,player.y,20,'#00ff41');
                if (player.weapon.type === 'shotgun') { player.weapon.buffs.dragonBreath = 3; showText("é¾™æ¯è£…å¡«!", player.x, player.y-60, '#ffaa00', 20); } 
                else if (player.weapon.type === 'smart_pistol') {
                    let targets = enemies.filter(e => getDist(player, e) < 600).sort((a,b)=>getDist(player,a)-getDist(player,b)).slice(0, 8);
                    targets.forEach((t, i) => { 
                        // ä½¿ç”¨å¯¹è±¡æ± 
                        setTimeout(() => { createBullet({x:player.x, y:player.y, vx:0, vy:0, target:t, type:'missile', size:4, life:2, damage:30, color:'#bc13fe', homing:true}); }, i*50); 
                    });
                    showText("å¤šé‡é”å®š", player.x, player.y-60, '#bc13fe', 20);
                } else if (player.weapon.type === 'monowire') { player.weapon.buffs.executionerTimer = 5.0; showText("å¤„å†³æ¨¡å¼", player.x, player.y-60, '#ff003c', 20); } 
                else if (player.weapon.type === 'tesla') {
                    createShockwave(player.x, player.y, '#00f3ff', 300);
                    enemies.forEach(e => { if (getDist(e, player) < 300) { takeDamage(e, 20, false, 'emp'); e.pushX = (e.x - player.x) * 3; e.pushY = (e.y - player.y) * 3; e.frozen = 2.0; } });
                    showText("ç”µç£è„‰å†²", player.x, player.y-60, '#00f3ff', 20);
                } else { showText("è¶…é¢‘!",player.x,player.y-40,'#00ff41'); }
            } else { w.isVenting=false; w.heat=Math.max(0,w.heat-5); w.jamTimer = 1.0; showText("å¤±è¯¯", player.x, player.y-40, '#ff003c'); playSound('jam'); }
        }
    }

    function useSkill() {
        if (player.skillCd > 0 || player.jammed || player.weapon.jamTimer > 0) { if (player.weapon.jamTimer > 0) playSound('jam'); return; }
        player.skillCd = player.maxSkillCd * (1 - player.stats.cooldownReduc); playSound('powerup'); showText("æŠ€èƒ½å‘åŠ¨", player.x, player.y-50, player.color);
        if (player.classId === 'solo') {
            createShockwave(player.x, player.y, '#ffaa00', 300); enemies.forEach(e => { if(getDist(e,player)<350) { e.pushX=(e.x-player.x)*2; e.pushY=(e.y-player.y)*2; takeDamage(e,50+player.weapon.damage*2,false,'skill'); }}); /* REMOVED: state.shake=25; */
        } else if (player.classId === 'netrunner') { enemies.forEach(e => { e.frozen=3; showText("å†»ç»“",e.x,e.y-20,'#bc13fe'); takeDamage(e,20,false,'skill'); }); } 
        else if (player.classId === 'samurai') { player.isDash=true; player.invincible=1.0; player.dashTimer=0.5; player.vx = Math.cos(player.angle)*1200; player.vy = Math.sin(player.angle)*1200; } 
        else if (player.classId === 'techie') { turrets.push({x:player.x, y:player.y, life:20, cooldown:0, range:300, damage:player.weapon.damage*0.8}); }
    }

    function showLevelUp() {
        const c = document.getElementById('upgrade-container'); c.innerHTML = ''; document.getElementById('levelup-screen').classList.remove('hidden');
        const pool = UPGRADE_POOL.filter(u => u.classes.includes('all') || u.classes.includes(player.classId));
        const opts = pool.sort(() => 0.5 - Math.random()).slice(0, 3);
        opts.forEach(u => {
            const d = document.createElement('div'); d.className = 'upgrade-card'; const isClass = u.classes.includes(player.classId) && !u.classes.includes('all');
            if (isClass) { d.style.borderColor = 'var(--neon-yellow)'; d.style.boxShadow = '0 0 15px var(--neon-yellow)'; }
            d.innerHTML = `<span class="upgrade-tag" style="color:${u.color};border-color:${u.color}">${u.tag}</span><h3 style="color:${u.color};margin:5px 0">${u.name}</h3><p style="font-size:0.9rem;color:#ddd">${u.desc}</p><small style="color:#aaa;margin-top:auto">ä»£ä»·: ${u.cost} äººæ€§</small>${isClass?'<div class="class-bonus">â˜… èŒä¸šä¸“å±</div>':''}`;
            d.onclick = () => { u.effect(player); player.humanity -= u.cost; state.upgrades.push(u); updateUpgradeList(); state.paused = false; document.getElementById('levelup-screen').classList.add('hidden'); state.lastTime = performance.now(); requestAnimationFrame(gameLoop); };
            c.appendChild(d);
        });
    }

    function updateUpgradeList() {
        const l = document.getElementById('menu-upgrade-list'); if(!state.upgrades.length) { l.innerHTML='<div style="text-align:center;color:#666">æ— </div>'; return; }
        l.innerHTML = state.upgrades.map(u => `<div class="upgrade-list-item"><span>${u.name}</span><span style="color:${u.color}">${u.tag}</span></div>`).join('');
    }

    function spawnWaveEnemy(dt) {
        if(state.bossActive) return; 
        const currentLevel = LEVEL_CONFIG[state.levelIndex];
        if(state.waveIndex >= currentLevel.waves.length) { if(!boss) spawnBoss(currentLevel.boss); return; }
        const currentWave = currentLevel.waves[state.waveIndex];
        if(state.waveKilled >= currentWave.count) {
             state.waveIndex++; state.waveSpawned = 0; state.waveKilled = 0;
             if(state.waveIndex < currentLevel.waves.length) { showText("ç¬¬ " + (state.waveIndex + 1) + " æ³¢", player.x, player.y - 100, '#00ff41'); if ((state.waveIndex + 1) % 2 === 0) spawnMarket(); } 
             else { showText("è­¦å‘Š: é¦–é¢†æ¥è¿‘ä¸­", player.x, player.y - 100, '#ff0000'); } return;
        }
        if(state.waveSpawned < currentWave.count) {
            state.spawnTimer -= dt;
            if(state.spawnTimer <= 0) {
                if (currentWave.formation) { 
                    const grp = Math.min(5, currentWave.count - state.waveSpawned); 
                    spawnEnemyGroup(currentWave.types, grp, currentWave.formation); 
                    state.waveSpawned += grp; 
                } 
                else { 
                    spawnEnemy(currentWave.types); 
                    state.waveSpawned++; 
                }
                state.spawnTimer = (1.0 / currentWave.rate) / state.difficulty.spawn;
            }
        }
    }

    function update(dt) {
        if (state.hitStop > 0) { state.hitStop -= dt; return; }
        
        // --- æ€§èƒ½ä¼˜åŒ–ï¼šç²’å­æ¸…ç†æ”¹ä¸ºé‡Šæ”¾åˆ°æ± ä¸­ ---
        // ç²’å­æ¸…ç†ä¸éœ€è¦ï¼Œå› ä¸ºç²’å­çš„ç”Ÿå‘½å‘¨æœŸåœ¨å®ƒä»¬è‡ªå·±çš„æ›´æ–°å¾ªç¯ä¸­ç®¡ç†ã€‚
        
        spawnWaveEnemy(dt);
        
        if (state.market.active) {
            state.market.timer -= dt;
            if (state.market.shieldTimer > 0) { state.market.shieldTimer -= dt; enemies.forEach(e => { if (getDist(e, state.market) < 200) { const angle = Math.atan2(e.y - state.market.y, e.x - state.market.x); e.pushX += Math.cos(angle) * 500 * dt; e.pushY += Math.sin(angle) * 500 * dt; } }); }
            if (state.market.timer <= 0) { state.market.active = false; showText("é»‘å¸‚å…³é—­", state.market.x, state.market.y - 50, '#aaa'); }
            else if (getDist(player, state.market) < 60) { state.market.interact += dt; if (state.market.interact > 2.0) { openMarket(); } } 
            else { state.market.interact = Math.max(0, state.market.interact - dt); }
        }

        if (player.stats.regen>0 && player.hp<player.maxHp && player.humanity>20 && !player.inGlitchZone) player.hp += player.stats.regen*dt;
        if (player.skillCd>0) player.skillCd -= dt;
        if (player.stats.flowStacks > 0) { player.stats.flowTimer -= dt; if (player.stats.flowTimer <= 0) { player.stats.flowStacks = Math.max(0, player.stats.flowStacks - 1); player.stats.flowTimer = 0.5; } }
        if (player.weapon.buffs.executionerTimer > 0) player.weapon.buffs.executionerTimer -= dt;
        if (player.weapon.anim && player.weapon.anim.timer > 0) player.weapon.anim.timer -= dt; 
        if (player.stats.staticField) enemies.forEach(e => { 
            // --- ä¼˜åŒ–ç‚¹ï¼šä½¿ç”¨ getDistSq è¿›è¡ŒèŒƒå›´æ£€æŸ¥ ---
            if (getDistSq(e, player) < 150*150) { 
                takeDamage(e, 5 * dt, false, 'static'); 
                if (Math.random() < 0.1) createExplosion(e.x, e.y, 1, '#00ff41'); 
            } 
        });
        
        player.jammed = false; enemies.forEach(e => { if (e.ai === 'debuff') player.jammed = true; });
        if (player.jammed && Math.random() < 0.05) showText("å¹²æ‰°", player.x, player.y - 50, '#00aa00', 10);

        if (player.isDash) {
            player.dashTimer-=dt; player.x+=player.vx*dt; player.y+=player.vy*dt;
            enemies.forEach(e=>{ 
                // --- ä¼˜åŒ–ç‚¹ï¼šä½¿ç”¨ getDistSq è¿›è¡Œç¢°æ’æ£€æŸ¥ ---
                if(getDistSq(e,player) < 60*60 && !e.hitByDash){ 
                    let dmg = player.weapon.damage * (player.stats.dashDmgMult || 5); 
                    takeDamage(e, dmg, true, 'dash'); 
                    e.hitByDash=true; 
                    createExplosion(e.x,e.y,10,'#ff003c'); 
                }
            });
            if(player.dashTimer<=0) { player.isDash=false; enemies.forEach(e=>e.hitByDash=false); if(player.hooks.onDashEnd) player.hooks.onDashEnd(); }
        } else {
            let dx=0, dy=0; 
            const up = player.inGlitchZone ? keys['KeyS'] : keys['KeyW']; const down = player.inGlitchZone ? keys['KeyW'] : keys['KeyS']; const left = player.inGlitchZone ? keys['KeyD'] : keys['KeyA']; const right = player.inGlitchZone ? keys['KeyA'] : keys['KeyD'];
            if(up) dy--; if(down) dy++; if(left) dx--; if(right) dx++;
            if(dx||dy) player.angle = Math.atan2(dy,dx);
            let spd = player.speed * (player.humanity<20 ? 1.4 : 1);
            if (player.stats.flowStacks) spd *= (1 + player.stats.flowStacks * 0.01);
            if(player.humanity<20) { player.hp-=dt*1.5; if(player.hp<=0) gameOver(); }
            if(dx||dy) { 
                const l=Math.hypot(dx,dy); const moveDist = spd * dt; let nx = player.x + dx/l*moveDist; let ny = player.y + dy/l*moveDist;
                let collided = false; state.obstacles.forEach(o => { if (nx > o.x && nx < o.x+o.w && nx > o.y && ny < o.y+o.h) collided = true; });
                if (!collided) { player.x = nx; player.y = ny; }
                if(player.hooks.onMove) player.hooks.onMove(moveDist); 
            }
        }
        
        camera.x += camera.kickX; camera.y += camera.kickY; camera.kickX *= 0.8; camera.kickY *= 0.8;
        camera.x += (player.x - state.width/2 - camera.x)*0.1; camera.y += (player.y - state.height/2 - camera.y)*0.1;

        const w = player.weapon; w.cooldown-=dt; if(w.overclockTimer>0) w.overclockTimer-=dt; if (w.jamTimer > 0) w.jamTimer -= dt;
        if(!w.isOverheated && !w.isVenting && w.jamTimer <= 0) {
            if(w.type==='monowire' && w.cooldown<=0) {
                let hit=false; const isExec = w.buffs.executionerTimer > 0; const rangeSq = (isExec ? w.range * 1.5 : w.range)**2;
                enemies.forEach(e=>{ 
                    // --- ä¼˜åŒ–ç‚¹ï¼šä½¿ç”¨ getDistSq è¿›è¡ŒèŒƒå›´æ£€æŸ¥ ---
                    if(getDistSq(e,player) < rangeSq) { 
                        let isCrit = Math.random() < player.stats.critRate; 
                        if(player.stats.iaiMode) { isCrit=true; player.stats.iaiMode=false; } 
                        let dmg = w.damage*(w.overclockTimer>0?1.5:1)*(isCrit?player.stats.critDmg:1); 
                        if(player.stats.iaiMode) dmg *= 2; 
                        takeDamage(e, dmg, isCrit, 'weapon'); hit=true; 
                    }
                });
                if(hit) { 
                    w.heat+=2; 
                    playSound('shoot'); 
                    /* ç§»é™¤æ”»å‡»æ—¶çš„é•œå¤´éœ‡åŠ¨: const kickAmt = 2; camera.kickX += Math.cos(player.angle + Math.PI) * kickAmt; camera.kickY += Math.sin(player.angle + Math.PI) * kickAmt; */ 
                    w.anim.timer = 0.2; 
                }
            } else if (w.cooldown<=0) {
                let target=null, minDSq=Infinity; enemies.forEach(e=>{const dSq=getDistSq(e,player); if(dSq<minDSq){minDSq=dSq; target=e;}});
                const rangeSq = w.range * w.range;
                if(target && minDSq < rangeSq) {
                    playSound('shoot'); player.lastAttackTime = state.globalTime; w.lastShotTime = state.globalTime;
                    let isCrit = Math.random() < player.stats.critRate; if(player.stats.iaiMode) { isCrit=true; player.stats.iaiMode=false; }
                    let dmg = w.damage*(w.overclockTimer>0?1.5:1); if(player.stats.zeroDay && target.hp < target.maxHp*0.25) dmg *= 2; if (player.stats.infiniteHeat) { player.hp -= 2; } 
                    const count = Math.max(1, w.count); const angle = Math.atan2(target.y-player.y, target.x-player.x);
                    
                    // ç§»é™¤æ”»å‡»æ—¶çš„é•œå¤´éœ‡åŠ¨:
                    // const kickAmt = w.type === 'shotgun' ? 10 : 3; camera.kickX += Math.cos(angle + Math.PI) * kickAmt; camera.kickY += Math.sin(angle + Math.PI) * kickAmt;
                    
                    if (w.type === 'shotgun') { player.vx -= Math.cos(angle) * 300; player.vy -= Math.sin(angle) * 300; }
                    if(w.type==='tesla') { for(let i=0; i<count; i++) fireTesla(target, dmg, i, isCrit); } 
                    else { 
                        let spread = w.spread + (w.type==='smart_pistol'&&count>1 ? 0.2:0); const isDragon = w.buffs.dragonBreath > 0; if (isDragon) w.buffs.dragonBreath--;
                        for(let i=0; i<count; i++) {
                            const a = angle + (count>1 ? (i-(count-1)/2)*spread : (w.type==='shotgun'?(Math.random()-0.5)*spread:0));
                            let p = 0; let r = player.stats.ricochet; let damage = dmg; let type = w.type==='shotgun'?'shell':'bullet'; let col = player.color;
                            if (isDragon) { p = 999; damage *= 2; type = 'dragon'; col = '#ff5500'; } else { p = player.stats.penetration; }
                            // ä½¿ç”¨å¯¹è±¡æ± 
                            createBullet({ x:player.x, y:player.y, vx:Math.cos(a)*w.projectileSpeed, vy:Math.sin(a)*w.projectileSpeed, target:target, type:type, size:w.type==='shotgun'?4:2, life:0.6, damage:damage, crit:isCrit, cDmg:player.stats.critDmg, pierce:p, ricochet:r, homing:player.stats.tracking||w.type==='smart_pistol', color: col });
                        }
                    }
                    const heatCost = (w.type==='shotgun'?20:10); if (!player.inGlitchZone) { w.heat += heatCost * (w.overclockTimer>0?0.5:1); } w.cooldown = w.fireRate * (w.overclockTimer>0?0.5:1) * (1-player.stats.cooldownReduc);
                }
            }
        }
        
        // --- æ€§èƒ½ä¼˜åŒ–ï¼šç²’å­åˆ›å»ºä½¿ç”¨å¯¹è±¡æ±  ---
        const activeBullets = bulletsPool.filter(b => b.active);
        activeBullets.forEach(b => { if (b.type === 'dragon' && Math.random() < 0.3) { hazards.push({type: 'fire', x: b.x, y: b.y, life: 2.0, radius: 20}); } });
        
        if (!player.stats.iaiMode && state.globalTime - player.lastAttackTime > 2.0 && state.upgrades && state.upgrades.find(u=>u.id==='iai_algo')) { player.stats.iaiMode = true; showText("å±…åˆå°±ç»ª", player.x, player.y-60, '#ff003c'); }
        if(w.heat >= w.maxHeat*(player.stats.heatCapMulti||1) && !player.stats.infiniteHeat) { w.heat=w.maxHeat*(player.stats.heatCapMulti||1); w.isOverheated=true; playSound('overheat'); if(player.hooks.onOverheat) player.hooks.onOverheat(); setTimeout(()=>{w.isOverheated=false; w.heat=0;},3000); }
        if(w.isVenting) { 
            w.ventProgress+=dt*w.ventSpeed; 
            const inSpot = w.ventProgress >= w.sweetSpotStart && w.ventProgress <= (w.sweetSpotStart + w.sweetSpotWidth);
            if (inSpot && !w.wasInSpot) { playSound('tick'); } w.isInSweetSpot = inSpot; w.wasInSpot = inSpot;
            if(w.ventProgress>=1){ w.isVenting=false; w.heat=Math.max(0,w.heat-10); w.jamTimer = 1.0; showText("å¤±è¯¯", player.x, player.y-40, '#ff003c'); playSound('jam'); } 
        }
        else if(!w.isOverheated && w.heat>0 && w.cooldown<-0.2 && w.jamTimer <= 0) { if (state.globalTime - w.lastShotTime > 1.5) { w.heat = Math.max(0, w.heat-dt*5); } }

        const lvl = LEVEL_CONFIG[Math.min(state.levelIndex, LEVEL_CONFIG.length-1)];
        document.getElementById('biome-name').innerText = lvl.name;
        const currentWave = lvl.waves[Math.min(state.waveIndex, lvl.waves.length-1)];
        const waveTarget = currentWave ? currentWave.count : 0;
        const waveProgressStr = state.bossActive ? "(é¦–é¢†)" : `(${state.waveKilled}/${waveTarget})`;
        document.getElementById('wave-display').innerText = state.bossActive ? "é¦–é¢†" : `ç¬¬ ${state.waveIndex+1} æ³¢`;
        document.getElementById('wave-progress').innerText = waveProgressStr;
        document.getElementById('credit-count').innerText = player.credits;
        updateHazards(dt, lvl);
        
        turrets.forEach((t,i)=>{
            t.life-=dt; t.cooldown-=dt; t.angle+=dt;
            if(t.cooldown<=0) { let tgt=null; enemies.forEach(e=>{if(getDist(e,t)<t.range) tgt=e;}); 
            if(tgt) { 
                // ä½¿ç”¨å¯¹è±¡æ± 
                createBullet({x:t.x,y:t.y,vx:(tgt.x-t.x)*3,vy:(tgt.y-t.y)*3,life:0.6,damage:t.damage,color:'#00ff41',type:'beam'}); 
                t.cooldown=0.5; 
            } }
            if(t.life<=0) { if(player.stats.turretExplode) createExplosion(t.x, t.y, 30, '#ff8800'); turrets.splice(i,1); }
        });

        // --- æ€§èƒ½ä¼˜åŒ–ï¼šæ›´æ–°å­å¼¹æ± ä¸­çš„æ´»åŠ¨å­å¼¹ ---
        for(let i=0; i<bulletsPool.length; i++) {
            const b = bulletsPool[i];
            if (!b.active) continue;

            b.life-=dt; 
            if(b.type === 'molotov_bottle') {
                const dist = Math.hypot(b.tx - b.x, b.ty - b.y); const speed = 400; const moveDist = speed * dt;
                if (dist < moveDist || b.life <= 0) { releaseToPool(b); createExplosion(b.x, b.y, 10, '#ff5500'); hazards.push({type:'fire', x:b.x, y:b.y, life:5}); continue; } 
                else { const angle = Math.atan2(b.ty - b.y, b.tx - b.x); b.x += Math.cos(angle) * moveDist; b.y += Math.sin(angle) * moveDist; }
            } else { b.x+=b.vx*dt; b.y+=b.vy*dt; }

            if(b.homing && b.target) {
                let targetX = b.target.x; let targetY = b.target.y;
                if (b.target.x !== undefined) { 
                    const angle = Math.atan2(targetY-b.y, targetX-b.x); 
                    b.vx += Math.cos(angle)*1500*dt; b.vy += Math.sin(angle)*1500*dt;
                    const s = Math.hypot(b.vx, b.vy); const ms = b.speed || 600; b.vx=(b.vx/s)*ms; b.vy=(b.vy/s)*ms;
                }
            }

            if(Math.random()<0.3) createParticle({x:b.x,y:b.y,vx:0,vy:0,life:0.2,color:b.color,size:2});
            if(b.life<=0) { releaseToPool(b); continue; }
            
            let blocked = false;
            if (b.type !== 'molotov_bottle') { state.obstacles.forEach(o => { if (b.x > o.x && b.x < o.x+o.w && b.y > o.y && b.y < o.y+o.h) blocked = true; }); }
            if (blocked && b.type !== 'dragon') { releaseToPool(b); createExplosion(b.x, b.y, 2, '#888'); continue; }

            if (b.type === 'tracker_orb' || b.type === 'enemy_bullet' || b.type === 'enemy_beam') { 
                 // --- ä¼˜åŒ–ç‚¹ï¼šä½¿ç”¨ getDistSq è¿›è¡Œç¢°æ’æ£€æŸ¥ ---
                 const bulletCollisionRadiusSq = (player.radius + 5) ** 2;
                 if (getDistSq(b, player) < bulletCollisionRadiusSq) {
                     if(player.invincible<=0) { 
                        if(player.shield) { player.shield=false; showText("æ ¼æŒ¡",player.x,player.y-30,'#00f3ff'); } 
                        else { 
                            player.hp -= b.damage; player.invincible=0.5; state.shake=10; playSound('hit'); 
                            if(player.hp<=0) gameOver(); 
                        } 
                    }
                     releaseToPool(b); continue;
                 }
            } else if (b.type !== 'molotov_bottle') { 
                // --- ä¼˜åŒ–ç‚¹ï¼šå­å¼¹å¯¹æ•Œäººç¢°æ’æ£€æµ‹ ---
                const collisionRadiusSq = 10 * 10; // å­å¼¹åŠå¾„å¹³æ–¹ + æœ€å°æ•ŒäººåŠå¾„å¹³æ–¹
                for(const e of enemies) {
                    if(b.hitList && b.hitList.includes(e)) continue;
                    
                    // --- ä¼˜åŒ–ç‚¹ï¼šä½¿ç”¨ getDistSq è¿›è¡Œç¢°æ’æ£€æŸ¥ ---
                    if(getDistSq(b,e) < (e.size+5)**2) {
                        const critMult = b.crit ? player.stats.critDmg : 1;
                        takeDamage(e, b.damage * critMult, b.crit, b.type === 'dragon' ? 'dragon' : 'weapon');
                        createExplosion(b.x, b.y, 3, player.color);
                        if(!b.hitList) b.hitList=[]; b.hitList.push(e);
                        if(b.pierce>0) { b.pierce--; b.damage*=0.8; } 
                        else if(b.ricochet>0) { 
                            b.ricochet--; b.hitList=[]; 
                            let nt=null, minDSq=400*400; // ä½¿ç”¨å¹³æ–¹è·ç¦»
                            enemies.forEach(ne=>{
                                // --- ä¼˜åŒ–ç‚¹ï¼šä½¿ç”¨ getDistSq è¿›è¡Œç´¢æ•Œæ£€æŸ¥ ---
                                if(ne!==e && getDistSq(ne,b)<minDSq) { 
                                    minDSq=getDistSq(ne,b); 
                                    nt=ne; 
                                }
                            }); 
                            if(nt) { 
                                const a=Math.atan2(nt.y-b.y,nt.x-b.x); 
                                const s=Math.hypot(b.vx,b.vy); 
                                b.vx=Math.cos(a)*s; b.vy=Math.sin(a)*s; 
                            } else { 
                                b.vx=-b.vx; b.vy=-b.vy; 
                            } 
                        } else { 
                            releaseToPool(b); 
                        }
                        break;
                    }
                }
            }
        }

        enemies.forEach(e => {
            if(e.hp<=0) return;
            if(e.frozen>0) { e.frozen-=dt; return; }
            AI_BEHAVIORS[e.ai || 'default'](e, player, dt);
            if (e.selfDestruct) { 
                createExplosion(e.x, e.y, 30, '#ff003c'); e.hp = 0; 
                // --- ä¼˜åŒ–ç‚¹ï¼šä½¿ç”¨ getDistSq è¿›è¡Œç¢°æ’æ£€æŸ¥ ---
                if (getDistSq(e, player) < 60*60 && player.invincible <= 0) { 
                    if(player.shield) { player.shield=false; showText("æ ¼æŒ¡",player.x,player.y-30,'#00f3ff'); } 
                    else { player.hp -= 20; player.invincible=0.5; state.shake=20; playSound('hit'); } 
                } 
            }

            let sx=0, sy=0; enemies.forEach(o=>{ 
                if(e!==o) { 
                    const dSq=getDistSq(e,o)||1; // è·ç¦»å¹³æ–¹
                    const d=Math.sqrt(dSq);
                    
                    if (d < e.size * 2) { 
                        sx+=(e.x-o.x)/d; 
                        sy+=(e.y-o.y)/d; 
                        if (d < e.size + o.size) { 
                            const overlap = (e.size + o.size - d) / 2; 
                            e.pushX += (e.x - o.x) / d * overlap * 10; 
                            e.pushY += (e.y - o.y) / d * overlap * 10; 
                        } 
                    } 
                } 
            });
            state.obstacles.forEach(o => { if (e.x > o.x - e.size && e.x < o.x + o.w + e.size && e.y > o.y - e.size && e.y < o.y + o.h + e.size) { const centerX = o.x + o.w/2; const centerY = o.y + o.h/2; const pushForce = 500 * dt; if (e.x < centerX) e.x -= pushForce; else e.x += pushForce; if (e.y < centerY) e.y -= pushForce; else e.y += pushForce; } });

            e.pushX*=0.9; e.pushY*=0.9; e.x += (Math.cos(e.angle)*e.speed + sx*50 + e.pushX)*dt; e.y += (Math.sin(e.angle)*e.speed + sy*50 + e.pushY)*dt;
            if (e.scale && e.scale !== 1) { e.scale += (1 - e.scale) * 10 * dt; } else { e.scale = 1; }
            
            // --- ä¼˜åŒ–ç‚¹ï¼šä½¿ç”¨ getDistSq è¿›è¡Œç¢°æ’æ£€æŸ¥ ---
            const enemyCollisionRadiusSq = (player.radius + e.size) ** 2;
            if(getDistSq(e,player) < enemyCollisionRadiusSq) {
                let canHit = true;
                if (e.ai === 'flank' && e.state === 1) canHit = false; 
                if (e.ai === 'suicide' && e.state === 1) canHit = false; 
                if (e.ai === 'drone_spiral') canHit = false; 

                if(canHit && player.invincible<=0) {
                    let dodged = Math.random()<player.stats.dodge; if(dodged && player.hooks.onDodge) player.hooks.onDodge();
                    if(dodged) { showText("é—ªé¿",player.x,player.y-30,'#00f3ff'); player.invincible=0.2; }
                    else { 
                        let dmg = 10*state.difficulty.dmg; if(player.stats.flatDmgReduc) dmg = Math.max(1, dmg - player.stats.flatDmgReduc);
                        if(player.shield) { player.shield=false; showText("æ ¼æŒ¡",player.x,player.y-30,'#00f3ff'); dmg=0; }
                        if(dmg > 0) { player.hp -= dmg; player.invincible=0.5; /* REMOVED: state.shake=10; */ playSound('hit'); if(player.hp<=0) gameOver(); }
                    }
                }
            }
        });
        enemies = enemies.filter(e=>e.hp>0);

        gems.forEach((g,i)=>{
            const dist = getDist(player, g);
            if(dist < 150 * (player.stats.xpRange||1)) { g.speed = (g.speed || 0) + 1500 * dt; const angle = Math.atan2(player.y - g.y, player.x - g.x); g.x += Math.cos(angle) * g.speed * dt; g.y += Math.sin(angle) * g.speed * dt; } else { g.speed = 0; }
            if(dist < 20) { state.xp += g.val*(player.stats.xpBonus||1); if(player.humanity<20) player.hp=Math.min(player.maxHp, player.hp+2); if(player.hooks.onXp) player.hooks.onXp(); if(state.xp >= state.nextLevelXp) { state.level++; state.xp-=state.nextLevelXp; state.nextLevelXp=Math.floor(state.nextLevelXp*1.5); state.paused=true; showLevelUp(); } gems.splice(i,1); playSound('pickup'); }
        });
        
        credits.forEach((c,i)=>{
            const dist = getDist(player, c);
            if(dist < 150 * (player.stats.xpRange||1)) { c.speed = (c.speed || 0) + 1500 * dt; const angle = Math.atan2(player.y - c.y, player.x - c.x); c.x += Math.cos(angle) * c.speed * dt; c.y += Math.sin(angle) * c.speed * dt; } else { c.speed = 0; }
            if(dist < 20) { player.credits += c.val; credits.splice(i,1); playSound('pickup'); }
        });

        // --- æ€§èƒ½ä¼˜åŒ–ï¼šæ›´æ–°ç²’å­æ± ä¸­çš„æ´»åŠ¨ç²’å­ ---
        for (let i = 0; i < particlesPool.length; i++) {
            const p = particlesPool[i];
            if (!p.active) continue;

            p.life -= dt; 
            if(p.type==='shockwave'){ /* handled in render */ } 
            else { p.x+=p.vx*dt; p.y+=p.vy*dt; } 
            
            if(p.life<=0) {
                releaseToPool(p);
            }
        }
        
        texts.forEach((d,i)=>{ d.x += (d.vx || 0) * dt; d.y += (d.vy || -30) * dt; d.life-=dt; if(d.life<=0) texts.splice(i,1); });
        if(player.invincible>0) player.invincible-=dt;
    }

    function render() {
        const t = state.globalTime;
        const lvl = LEVEL_CONFIG[Math.min(state.levelIndex, LEVEL_CONFIG.length-1)];
        if(player.humanity<20 && Math.random()<0.05) { ctx.fillStyle='#200'; ctx.fillRect(0,0,state.width,state.height); }
        else { ctx.fillStyle=lvl.color; ctx.fillRect(0,0,state.width,state.height); drawGrid(ctx, lvl, t); }
        if(state.shake>0) { ctx.save(); ctx.translate((Math.random()-0.5)*state.shake, (Math.random()-0.5)*state.shake); state.shake*=0.9; } else ctx.save();
        ctx.translate(-camera.x, -camera.y);

        state.obstacles.forEach(o => { ctx.fillStyle = o.color; ctx.shadowBlur = 10; ctx.shadowColor = '#000'; ctx.fillRect(o.x, o.y, o.w, o.h); ctx.strokeStyle = '#222'; ctx.strokeRect(o.x, o.y, o.w, o.h); ctx.beginPath(); ctx.moveTo(o.x, o.y); ctx.lineTo(o.x+o.w, o.y+o.h); ctx.stroke(); ctx.shadowBlur = 0; });

        state.glitchZones.forEach(z => { ctx.fillStyle = `rgba(188, 19, 254, ${0.1 + Math.random()*0.1})`; ctx.fillRect(z.x, z.y, z.w, z.h); if(Math.random() < 0.1) { ctx.fillStyle = '#fff'; ctx.fillRect(z.x + Math.random()*z.w, z.y + Math.random()*z.h, 20, 5); } ctx.strokeStyle = '#bc13fe'; ctx.lineWidth = 1; ctx.strokeRect(z.x, z.y, z.w, z.h); });

        if (state.trafficWarning > 0) {
            const laneY = state.trafficLaneY;
            ctx.fillStyle = `rgba(255, 0, 0, ${0.2 + 0.1 * Math.sin(t*20)})`; ctx.fillRect(player.x - 2000, laneY - 100, 4000, 200);
            ctx.strokeStyle = '#ff003c'; ctx.lineWidth = 2; ctx.setLineDash([20, 20]);
            ctx.beginPath(); ctx.moveTo(player.x - 2000, laneY - 100); ctx.lineTo(player.x + 2000, laneY - 100); ctx.moveTo(player.x - 2000, laneY + 100); ctx.lineTo(player.x + 2000, laneY + 100); ctx.stroke(); ctx.setLineDash([]);
            ctx.fillStyle = '#ff0000'; ctx.font = '40px "Share Tech Mono"'; ctx.textAlign = 'center'; ctx.fillText("!!! è½¨é“è­¦æŠ¥ !!!", player.x, laneY - 120);
        }

        hazards.forEach(h => {
            if(h.type==='train') { ctx.fillStyle = '#ff003c'; ctx.shadowBlur = 20; ctx.shadowColor = '#ff003c'; ctx.fillRect(h.x, h.y - h.h/2, h.w, h.h); ctx.fillStyle = '#fff'; ctx.fillRect(h.x + Math.random()*h.w, h.y - h.h/2 + Math.random()*h.h, 100, 2); ctx.shadowBlur = 0; } 
            else if(h.type==='steam') { ctx.fillStyle=`rgba(200,200,200,${0.1+Math.sin(t+h.x)*0.05})`; ctx.beginPath(); ctx.arc(h.x,h.y,h.radius,0,Math.PI*2); ctx.fill(); }
            else if(h.type==='fire') { ctx.fillStyle = `rgba(255, 100, 0, ${0.5 + Math.sin(t*10)*0.2})`; ctx.beginPath(); ctx.arc(h.x, h.y, h.radius, 0, Math.PI*2); ctx.fill(); }
        });

        if (state.market.active) {
            const mx = state.market.x, my = state.market.y;
            if (getDist(player, state.market) > 600) { const angle = Math.atan2(my - player.y, mx - player.x); const ix = player.x + Math.cos(angle) * 300; const iy = player.y + Math.sin(angle) * 300; ctx.fillStyle = '#00ff00'; ctx.beginPath(); ctx.arc(ix, iy, 10, 0, Math.PI*2); ctx.fill(); }
            if (state.market.shieldTimer > 0) { ctx.beginPath(); ctx.arc(mx, my, 200, 0, Math.PI * 2); ctx.fillStyle = `rgba(0, 255, 65, ${0.1 + Math.sin(t*10)*0.05})`; ctx.fill(); ctx.strokeStyle = '#00ff41'; ctx.lineWidth = 2; ctx.stroke(); }
            ctx.fillStyle = '#004400'; ctx.beginPath(); ctx.arc(mx, my, 40, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(mx, my, 40, 0, Math.PI*2); ctx.stroke(); ctx.fillStyle = '#00ff00'; ctx.font='12px "Share Tech Mono"'; ctx.fillText("é»‘å¸‚", mx-20, my-50);
            ctx.beginPath(); ctx.arc(mx, my, 60, 0, Math.PI*2); ctx.strokeStyle = 'rgba(0,255,0,0.3)'; ctx.lineWidth=2; ctx.stroke(); if (state.market.interact > 0) { ctx.beginPath(); ctx.arc(mx, my, 60, 0, Math.PI * 2 * (state.market.interact/2)); ctx.strokeStyle = '#00ff00'; ctx.lineWidth=4; ctx.stroke(); }
        }

        turrets.forEach(t=>{ ctx.shadowBlur=10; ctx.shadowColor='#00ff41'; ctx.fillStyle='#003300'; ctx.beginPath(); ctx.arc(t.x,t.y,15,0,Math.PI*2); ctx.fill(); ctx.save(); ctx.translate(t.x,t.y); ctx.rotate(t.angle); ctx.fillStyle='#00ff41'; ctx.fillRect(-10,-10,20,20); ctx.fillRect(5,-4,15,8); ctx.restore(); ctx.shadowBlur=0; });
        gems.forEach(g=>{ ctx.shadowBlur=10; ctx.shadowColor='#00ff41'; ctx.fillStyle='#00ff41'; ctx.beginPath(); ctx.moveTo(g.x,g.y-5); ctx.lineTo(g.x+5,g.y); ctx.lineTo(g.x,g.y+5); ctx.lineTo(g.x-5,g.y); ctx.fill(); ctx.shadowBlur=0; });
        credits.forEach(c=>{ ctx.shadowBlur=10; ctx.shadowColor='#fcee0a'; ctx.fillStyle='#fcee0a'; ctx.fillRect(c.x-4,c.y-4,8,8); ctx.shadowBlur=0; });

        enemies.forEach(e=>{
            // === èµ›åšçŒçŠ¬é¢„è­¦ (Flank Warning) ===
            if (e.ai === 'flank' && e.state === 1 && e.timer > 0) {
                ctx.beginPath();
                ctx.moveTo(e.x, e.y);
                ctx.lineTo(player.x, player.y);
                // é—ªçƒçš„æ©™è‰²çº¿æ¡
                ctx.strokeStyle = `rgba(255, 100, 0, ${0.5 + Math.sin(t*20)*0.4})`; 
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            if (e.ai === 'suicide' && e.state === 1) { ctx.beginPath(); ctx.arc(e.x, e.y, 200 * (1 - e.timer/0.8), 0, Math.PI*2); ctx.fillStyle = 'rgba(255, 0, 0, 0.4)'; ctx.fill(); ctx.strokeStyle = 'red'; ctx.stroke(); }
            if (e.ai === 'sniper' && e.timer < 3.0) { ctx.beginPath(); ctx.moveTo(e.x, e.y); const range = 800; ctx.lineTo(e.x + Math.cos(e.angle)*range, e.y + Math.sin(e.angle)*range); if (e.timer > 2.0) { ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)'; ctx.lineWidth = 2; } else { ctx.strokeStyle = 'rgba(255, 0, 0, 0.2)'; ctx.lineWidth = 1; } ctx.stroke(); }
            if (e.ai === 'boss' && e.state === 'smash_prep') { const maxR = 300; const progress = 1 - (e.timer / 1.5); ctx.beginPath(); ctx.arc(e.x, e.y, maxR, 0, Math.PI*2); ctx.strokeStyle = 'red'; ctx.lineWidth = 2; ctx.stroke(); ctx.beginPath(); ctx.arc(e.x, e.y, maxR * progress, 0, Math.PI*2); ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; ctx.fill(); }

            ctx.shadowBlur=10; ctx.shadowColor=e.color; ctx.strokeStyle=e.frozen>0?'#00ffff':e.color; ctx.lineWidth=2;
            if ((e.ai === 'flank' && e.state === 1) || (e.ai === 'suicide' && e.state === 1)) { if (Math.floor(Date.now() / 100) % 2 === 0) ctx.globalAlpha = 0.5; }
            ctx.save(); ctx.translate(e.x,e.y); ctx.rotate(e.angle); if(e.scale) ctx.scale(e.scale, 2 - e.scale); 
            if (e.ai === 'barrier') { ctx.beginPath(); ctx.arc(0,0,150,0,Math.PI*2); ctx.strokeStyle = 'cyan'; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]); ctx.fillStyle = 'rgba(0,255,255,0.1)'; ctx.fill(); drawPoly(ctx, 0, 0, e.size, 6, 0, e.color); }
            else if (e.ai === 'shielder') { 
                ctx.fillRect(-10,-10,20,20); 
                if (e.shield) { ctx.beginPath(); ctx.arc(0,0,30, -Math.PI/2, Math.PI/2); const shieldPct = e.shieldHp / e.maxShieldHp; ctx.strokeStyle = `rgba(0, 243, 255, ${0.3 + shieldPct * 0.7})`; ctx.lineWidth = 6; ctx.stroke(); ctx.fillStyle = `rgba(0, 243, 255, ${0.1 * shieldPct})`; ctx.fill(); }
            }
            else if (e.shape === 'boss') { drawPoly(ctx, 0, 0, e.size, 5, 0, e.color); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(-15,-10,8,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(15,-10,8,0,Math.PI*2); ctx.fill(); }
            else if (e.shape === 'circle') { ctx.beginPath(); ctx.arc(0,0,e.size,0,Math.PI*2); ctx.stroke(); }
            else if (e.shape === 'rect') { ctx.strokeRect(-e.size/2, -e.size/2, e.size, e.size); }
            else if (e.shape === 'triangle') { drawPoly(ctx, 0, 0, e.size, 3, 0, e.color); }
            else if (e.shape === 'x') { ctx.beginPath(); ctx.moveTo(-e.size,-e.size); ctx.lineTo(e.size,e.size); ctx.moveTo(e.size,-e.size); ctx.lineTo(-e.size,e.size); ctx.stroke(); }
            else if (e.shape === 'cross') { ctx.beginPath(); ctx.moveTo(0,-e.size); ctx.lineTo(0,e.size); ctx.moveTo(-e.size,0); ctx.lineTo(e.size,0); ctx.stroke(); }
            else { drawPoly(ctx, 0, 0, e.size, 4, 0, e.color); }
            if(e.hp<e.maxHp && !e.isBoss) { ctx.fillStyle='#330000'; ctx.fillRect(-15,-e.size-10,30,4); ctx.fillStyle='red'; ctx.fillRect(-15,-e.size-10,30*(e.hp/e.maxHp),4); }
            if (e.shield && e.shieldHp < e.maxShieldHp) { ctx.fillStyle='#003333'; ctx.fillRect(-15,-e.size-16,30,3); ctx.fillStyle='#00f3ff'; ctx.fillRect(-15,-e.size-16,30*(e.shieldHp/e.maxShieldHp),3); }
            ctx.globalAlpha = 1.0; ctx.restore(); ctx.shadowBlur=0;
        });

        ctx.shadowBlur=20; ctx.shadowColor=player.color;
        if(player.isDash) { ctx.globalAlpha=0.3; ctx.beginPath(); ctx.arc(player.x-player.vx*0.05, player.y-player.vy*0.05, player.radius, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
        ctx.strokeStyle=player.color; ctx.lineWidth=2;
        ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(t*3); ctx.beginPath(); ctx.arc(0,0,player.radius,0,Math.PI*1.5); ctx.stroke(); ctx.restore();
        ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(player.angle); ctx.fillStyle=player.color; ctx.beginPath(); ctx.moveTo(player.radius+5,0); ctx.lineTo(player.radius-5,-5); ctx.lineTo(player.radius-5,5); ctx.fill(); ctx.restore();
        if(player.shield) { ctx.strokeStyle='cyan'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(player.x,player.y,player.radius+5,0,Math.PI*2); ctx.stroke(); }
        
        if(player.weapon.type==='monowire') {
            ctx.save(); ctx.translate(player.x, player.y);
            ctx.rotate(t * 0.5); ctx.beginPath(); ctx.arc(0, 0, player.weapon.range, 0, Math.PI*2); ctx.strokeStyle = 'rgba(255, 0, 60, 0.15)'; ctx.lineWidth = 1.5; ctx.setLineDash([5, 30]); ctx.stroke(); ctx.setLineDash([]);
            if (player.weapon.anim.timer > 0) {
                const anim = player.weapon.anim; const p = 1 - (anim.timer / 0.2); const isExec = player.weapon.buffs.executionerTimer > 0; const baseColor = isExec ? '#bc13fe' : '#ff003c'; const rangeMult = isExec ? 1.5 : 1.0; const currentRadius = player.weapon.range * rangeMult;
                ctx.shadowBlur = isExec ? 40 : 25; ctx.shadowColor = baseColor; ctx.rotate(p * Math.PI * 12);
                for(let i=0; i<3; i++) { ctx.beginPath(); const radiusVar = currentRadius * (0.9 + Math.random() * 0.2); const startAngle = i * (Math.PI * 2 / 3); const endAngle = startAngle + Math.PI + (Math.random() * 0.5); ctx.arc(0, 0, radiusVar, startAngle, endAngle); ctx.strokeStyle = baseColor; ctx.lineWidth = (1-p) * 8 + Math.random() * 4; ctx.stroke(); }
                if (Math.random() < 0.4) { ctx.beginPath(); const len = currentRadius * 1.5; ctx.moveTo(-len, (Math.random()-0.5)*20); ctx.lineTo(len, (Math.random()-0.5)*20); ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.lineWidth = 1; ctx.stroke(); }
                ctx.beginPath(); ctx.arc(0, 0, currentRadius, 0, Math.PI*2); ctx.fillStyle = baseColor; ctx.globalAlpha = 0.2 * (1-p); ctx.fill();
                if (isExec) { ctx.globalAlpha = 0.5; ctx.strokeStyle = '#00f3ff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(5, 0, currentRadius, 0, Math.PI*2); ctx.stroke(); }
            }
            ctx.restore();
        }
        drawPlayerHUD(ctx); ctx.shadowBlur=0;

        ctx.globalCompositeOperation='lighter';
        // --- æ€§èƒ½ä¼˜åŒ–ï¼šæ¸²æŸ“å­å¼¹æ± ä¸­çš„æ´»åŠ¨å­å¼¹ ---
        bulletsPool.forEach(b => { 
            if (!b.active) return;
            ctx.fillStyle=b.color; ctx.shadowBlur=10; ctx.shadowColor=b.color; 
            if(b.type==='beam') {
                ctx.fillRect(b.x-20, b.y-2, 40, 4); 
            } else { 
                ctx.beginPath(); ctx.arc(b.x,b.y,b.size||2,0,Math.PI*2); ctx.fill(); 
            } 
            ctx.shadowBlur=0; 
        });

        ctx.globalCompositeOperation='source-over';
        // --- æ€§èƒ½ä¼˜åŒ–ï¼šæ¸²æŸ“ç²’å­æ± ä¸­çš„æ´»åŠ¨ç²’å­ ---
        particlesPool.forEach(p => { 
            if (!p.active) return;
            
            if(p.type==='lightning') { 
                ctx.strokeStyle=p.color; ctx.lineWidth=2; ctx.shadowBlur=10; ctx.shadowColor=p.color; ctx.beginPath(); 
                if(p.chain.length){ctx.moveTo(player.x,player.y); p.chain.forEach(pt=>ctx.lineTo(pt.x,pt.y));} 
                ctx.stroke(); ctx.shadowBlur=0; 
            } else if(p.type==='shockwave') { 
                ctx.strokeStyle=p.color; const pr=1-(p.life/0.5); ctx.lineWidth=5*(1-pr); ctx.beginPath(); ctx.arc(p.x,p.y,p.maxRadius*pr,0,Math.PI*2); ctx.stroke(); 
                ctx.fillStyle=p.color; ctx.globalAlpha=0.2*(1-pr); ctx.fill(); 
                ctx.globalAlpha=1; 
            } else { 
                ctx.fillStyle=p.color; 
                ctx.globalAlpha=p.life*2>1?1:p.life*2; 
                ctx.fillRect(p.x,p.y,p.size,p.size); 
                ctx.globalAlpha=1; 
            } 
        });
        
        texts.forEach(d=>{ ctx.shadowBlur=5; ctx.shadowColor=d.color; ctx.fillStyle=d.color; ctx.font=`bold ${d.size}px "Share Tech Mono"`; ctx.fillText(d.text,d.x,d.y); ctx.shadowBlur=0; });
        ctx.restore();
        renderMinimap();
        updateUIElements();
    }

    function drawPlayerHUD(ctx) {
        const x = player.x; const y = player.y; const r = player.radius + 20; const w = player.weapon;
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(50, 50, 50, 0.5)'; ctx.lineWidth = 3; ctx.stroke();
        const heatPct = w.heat / (w.maxHeat * (player.stats.heatCapMulti || 1)); const jammed = w.jamTimer > 0;
        ctx.beginPath(); ctx.arc(x, y, r, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * heatPct)); ctx.strokeStyle = jammed ? '#888' : (w.isOverheated ? '#ff003c' : (heatPct > 0.8 ? '#ff8800' : '#fcee0a')); ctx.lineWidth = 3; ctx.stroke();
        if (w.isVenting) {
            const startAngle = -Math.PI/2 + (Math.PI * 2 * w.sweetSpotStart); const endAngle = startAngle + (Math.PI * 2 * w.sweetSpotWidth); const cursorAngle = -Math.PI/2 + (Math.PI * 2 * w.ventProgress);
            ctx.beginPath(); ctx.arc(x, y, r + 6, startAngle, endAngle); ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 5; ctx.stroke();
            ctx.beginPath(); if (w.isInSweetSpot) { ctx.arc(x, y, r + 8, cursorAngle - 0.15, cursorAngle + 0.15); ctx.strokeStyle = '#00ff41'; ctx.lineWidth = 8; ctx.shadowBlur = 15; ctx.shadowColor = '#00ff41'; } else { ctx.arc(x, y, r + 6, cursorAngle - 0.1, cursorAngle + 0.1); ctx.strokeStyle = '#ff003c'; ctx.lineWidth = 5; ctx.shadowBlur = 0; } ctx.stroke(); ctx.shadowBlur = 0;
        }
        if (w.isOverheated) { ctx.fillStyle = '#ff003c'; ctx.font = '10px "Share Tech Mono"'; ctx.textAlign = 'center'; ctx.fillText("è¿‡çƒ­", x, y - r - 8); } 
        else if (jammed) { ctx.fillStyle = '#ff003c'; ctx.font = '10px "Share Tech Mono"'; ctx.textAlign = 'center'; ctx.fillText("å¡å£³", x, y - r - 8); }
    }

    function drawGrid(ctx, biome, t) {
        const sz=80, ox=Math.floor(camera.x)%sz, oy=Math.floor(camera.y)%sz;
        ctx.strokeStyle=biome.grid; ctx.lineWidth=2; ctx.beginPath();
        for(let x=-ox; x<state.width; x+=sz) { ctx.moveTo(x,0); ctx.lineTo(x,state.height); }
        for(let y=-oy; y<state.height; y+=sz) { const s=(Math.sin(y/100+t*2)+1)*0.5; ctx.lineWidth=1+s*2; ctx.strokeStyle=`rgba(0,243,255,${0.1+s*0.1})`; ctx.moveTo(0,y); ctx.lineTo(state.width,y); }
        ctx.stroke();
    }
    
    function drawPoly(ctx, x, y, r, s, a, c) {
        ctx.beginPath(); for(let i=0; i<s; i++) { const th=a+i*2*Math.PI/s; i===0?ctx.moveTo(x+Math.cos(th)*r, y+Math.sin(th)*r):ctx.lineTo(x+Math.cos(th)*r, y+Math.sin(th)*r); } ctx.closePath(); ctx.strokeStyle=c; ctx.lineWidth=2; ctx.stroke(); ctx.fillStyle=c; ctx.globalAlpha=0.2; ctx.fill(); ctx.globalAlpha=1;
    }

    function renderMinimap() {
        mmCtx.fillStyle='rgba(0,10,0,0.9)'; mmCtx.fillRect(0,0,160,160);
        const cx=80, cy=80, range=2000, scl=80/range;
        mmCtx.strokeStyle='rgba(0,255,0,0.2)'; mmCtx.beginPath(); mmCtx.arc(cx,cy,48,0,Math.PI*2); mmCtx.stroke();
        
        enemies.forEach(e=>{ 
            // --- ä¼˜åŒ–ç‚¹ï¼šä½¿ç”¨ getDistSq è¿›è¡ŒèŒƒå›´æ£€æŸ¥ ---
            if(getDistSq(e,player) < range*range) { 
                mmCtx.fillStyle=e.isBoss?'#ff0000':'#ff003c'; mmCtx.beginPath(); mmCtx.arc(cx+(e.x-player.x)*scl, cy+(e.y-player.y)*scl, e.isBoss?4:2, 0, Math.PI*2); mmCtx.fill(); 
            }
        });
        
        mmCtx.fillStyle='#00ff41'; 
        gems.forEach(g=>{ 
            // --- ä¼˜åŒ–ç‚¹ï¼šä½¿ç”¨ getDistSq è¿›è¡ŒèŒƒå›´æ£€æŸ¥ ---
            if(getDistSq(g,player) < range*range) 
            mmCtx.fillRect(cx+(g.x-player.x)*scl, cy+(g.y-player.y)*scl, 1.5, 1.5); 
        });

        // ç»˜åˆ¶é»‘å¸‚ä½ç½®
        if (state.market.active) {
            const mx = cx + (state.market.x - player.x) * scl;
            const my = cy + (state.market.y - player.y) * scl;
            mmCtx.fillStyle = '#00ff41'; // ç»¿ç‚¹
            mmCtx.beginPath();
            mmCtx.arc(mx, my, 4, 0, Math.PI * 2);
            mmCtx.fill();
        }

        // ç»˜åˆ¶ç©å®¶
        mmCtx.save(); mmCtx.translate(cx,cy); mmCtx.rotate(player.angle); mmCtx.fillStyle='#fff'; mmCtx.beginPath(); mmCtx.moveTo(4,0); mmCtx.lineTo(-3,-3); mmCtx.lineTo(-3,3); mmCtx.fill(); mmCtx.restore();
    }

    function updateUIElements() {
        const m=Math.floor(state.timeElapsed/60), s=Math.floor(state.timeElapsed%60).toString().padStart(2,'0');
        document.getElementById('timer').innerText=`${m}:${s}`;
        document.getElementById('kill-count').innerText=state.kills;
        document.getElementById('level').innerText=state.level;
        document.getElementById('hp-bar-fill').style.width=Math.max(0,player.hp/player.maxHp*100)+'%';
        document.getElementById('hp-text').innerText=`${Math.ceil(player.hp)}/${Math.ceil(player.maxHp)}`;
        document.getElementById('humanity-bar-fill').style.width=Math.max(0,player.humanity)+'%';
        const xpPct = Math.min(100, (state.xp / state.nextLevelXp) * 100);
        document.getElementById('xp-bar-fill').style.width = xpPct + '%';
        document.getElementById('shield-bar-fill').style.width = player.shield ? '100%' : Math.max(0, (player.stats.shieldCharge||0)/500*100)+'%';
        const hStat=document.getElementById('humanity-status');
        if(player.humanity<20) { hStat.innerText="èµ›åšç²¾ç¥ç—…"; hStat.style.color="var(--neon-red)"; hStat.classList.add("glitched-text"); }
        else { hStat.innerText=player.humanity<50?"ä¸ç¨³å®š":"ç¨³å®š"; hStat.style.color=player.humanity<50?"var(--neon-yellow)":"var(--neon-blue)"; hStat.classList.remove("glitched-text"); }
        const cdPct = Math.max(0, (player.skillCd/player.maxSkillCd)*100);
        document.getElementById('skill-cd-overlay').style.height = cdPct+'%';
        const sBox = document.getElementById('skill-box');
        if(player.skillCd<=0) { sBox.classList.add('ready'); document.getElementById('skill-timer').innerText="å°±ç»ª"; document.getElementById('skill-timer').style.color="var(--neon-green)"; }
        else { sBox.classList.remove('ready'); document.getElementById('skill-timer').innerText=player.skillCd.toFixed(1); document.getElementById('skill-timer').style.color="#888"; }
        if(state.bossActive && boss) document.getElementById('boss-bar-fill').style.width=(boss.hp/boss.maxHp*100)+'%';
    }

    // --- æ€§èƒ½ä¼˜åŒ–ï¼šåˆ›å»ºå¯¹è±¡æ—¶ä½¿ç”¨å¯¹è±¡æ± æ–¹æ³• ---
    function createExplosion(x,y,c,col) { for(let i=0;i<c;i++) createParticle({x:x,y:y,vx:(Math.random()-0.5)*200,vy:(Math.random()-0.5)*200,life:0.4+Math.random()*0.4,color:col,size:Math.random()*3+1, type: 'explosion'}); }
    function createShockwave(x,y,col,rad) { createParticle({x:x,y:y,vx:0,vy:0,life:0.5,color:col,size:10,type:'shockwave',maxRadius:rad}); }
    function showText(t,x,y,c,s=16) { texts.push({text:t,x:x,y:y,color:c,life:1,size:s}); }
    function gameOver() { state.isRunning=false; document.getElementById('final-time').innerText=document.getElementById('timer').innerText; document.getElementById('final-kills').innerText=state.kills; document.getElementById('gameover-screen').classList.remove('hidden'); }
    function playSound(t) { if(audioCtx.state==='suspended')audioCtx.resume(); const o=audioCtx.createOscillator(),g=audioCtx.createGain(),now=audioCtx.currentTime; o.connect(g); g.connect(audioCtx.destination); if(t==='shoot'){o.frequency.setValueAtTime(200,now);o.frequency.exponentialRampToValueAtTime(50,now+0.1);g.gain.setValueAtTime(0.05,now);g.gain.linearRampToValueAtTime(0,now+0.1);o.start(now);o.stop(now+0.1);} else if(t==='hit'){o.type='sawtooth';o.frequency.setValueAtTime(100,now);g.gain.setValueAtTime(0.05,now);g.gain.linearRampToValueAtTime(0,now+0.1);o.start(now);o.stop(now+0.1);} else if(t==='powerup'){o.frequency.setValueAtTime(400,now);o.frequency.linearRampToValueAtTime(800,now+0.3);g.gain.setValueAtTime(0.05,now);g.gain.linearRampToValueAtTime(0,now+0.3);o.start(now);o.stop(now+0.3);} else if(t==='jam'){o.type='square';o.frequency.setValueAtTime(100,now);g.gain.setValueAtTime(0.05,now);g.gain.linearRampToValueAtTime(0,now+0.2);o.start(now);o.stop(now+0.2);} else if(t==='overheat'){o.type='triangle';o.frequency.setValueAtTime(300,now);o.frequency.linearRampToValueAtTime(100,now+0.5);g.gain.setValueAtTime(0.1,now);g.gain.linearRampToValueAtTime(0,now+0.5);o.start(now);o.stop(now+0.5);} else if(t==='tick'){o.type='sine';o.frequency.setValueAtTime(800,now);g.gain.setValueAtTime(0.02,now);g.gain.exponentialRampToValueAtTime(0.001,now+0.05);o.start(now);o.stop(now+0.05);} }

    function gameLoop(t) { if(!state.isRunning)return; const dt=(t-state.lastTime)/1000; state.lastTime=t; if(!state.paused){state.timeElapsed+=dt; state.globalTime+=dt; update(dt); render();} requestAnimationFrame(gameLoop); }
    
    initUI();
</script>
</body>
</html>
