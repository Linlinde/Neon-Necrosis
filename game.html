<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÈúìËôπÂùèÊ≠ª | Neon Necrosis: Night City Legend</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
        :root { --neon-blue:#00f3ff; --neon-pink:#ff00ff; --neon-green:#00ff41; --neon-yellow:#fcee0a; --neon-red:#ff003c; --neon-purple:#bc13fe; --bg-color:#050510; }
        body { margin:0; overflow:hidden; background-color:var(--bg-color); font-family:'Share Tech Mono',monospace; color:white; user-select:none; }
        #game-container { position:relative; width:100vw; height:100vh; }
        canvas { display:block; }
        .scanlines { position:absolute; top:0; left:0; width:100%; height:100%; background:linear-gradient(to bottom, rgba(18,16,16,0) 50%, rgba(0,0,0,0.2) 50%); background-size:100% 4px; pointer-events:none; z-index:10; }
        .vignette { position:absolute; top:0; left:0; width:100%; height:100%; background:radial-gradient(circle, transparent 60%, rgba(0,0,0,0.9) 100%); pointer-events:none; z-index:10; box-shadow:inset 0 0 100px rgba(0,0,0,0.9); }
        #ui-layer { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:20; display:flex; flex-direction:column; justify-content:space-between; padding:20px; box-sizing:border-box; }
        .top-bar { display:flex; justify-content:space-between; align-items:flex-start; }
        .stats-box { background:rgba(5,5,10,0.8); border:1px solid var(--neon-blue); padding:10px; box-shadow:0 0 15px rgba(0,243,255,0.3); text-shadow:0 0 5px var(--neon-blue); backdrop-filter:blur(4px); border-radius:4px; font-size:1.1rem; min-width: 200px; }
        .status-bars-container { width:300px; text-align:right; }
        .bar-bg { width:100%; height:12px; background:#222; margin-bottom:8px; border:1px solid #444; position:relative; }
        .bar-fill { height:100%; transition:width 0.2s, background-color 0.3s; }
        .xp-bar-container { width: 100%; height: 4px; background: #222; margin-top: 2px; border: 1px solid #444; position: relative; }
        .xp-bar-fill { height: 100%; background: var(--neon-yellow); width: 0%; transition: width 0.2s; box-shadow: 0 0 5px var(--neon-yellow); }
        #hp-bar-fill { background:var(--neon-green); box-shadow:0 0 10px var(--neon-green); }
        #humanity-bar-fill { background:var(--neon-blue); box-shadow:0 0 10px var(--neon-blue); }
        #shield-bar-fill { background:var(--neon-blue); position:absolute; top:0; left:0; height:100%; width:0%; opacity:0.7; box-shadow:0 0 5px cyan; }
        #boss-ui { position:absolute; top:80px; left:50%; transform:translateX(-50%); width:60%; display:none; }
        .boss-name { text-align:center; color:var(--neon-red); font-size:1.5rem; text-shadow:0 0 10px var(--neon-red); margin-bottom:5px; letter-spacing:5px; }
        #boss-bar-fill { background:var(--neon-red); box-shadow:0 0 20px var(--neon-red); }
        .skill-cooldown { width:70px; height:70px; border:2px solid #555; position:absolute; bottom:30px; right:30px; display:flex; flex-direction:column; justify-content:center; align-items:center; background:rgba(0,0,0,0.6); color:#888; transition:all 0.2s; transform:skew(-10deg); overflow:hidden; }
        .skill-cooldown.ready { border-color:var(--neon-green); box-shadow:0 0 20px var(--neon-green); color:var(--neon-green); }
        .skill-overlay { position:absolute; bottom:0; left:0; width:100%; background:rgba(0,0,0,0.8); height:0%; transition:height 0.1s linear; }
        .skill-info { z-index:1; display:flex; flex-direction:column; align-items:center; transform:skew(10deg); }
        #minimap-container { position:absolute; bottom:30px; left:30px; width:160px; height:160px; border:2px solid var(--neon-blue); background:rgba(0,10,0,0.85); border-radius:50%; overflow:hidden; box-shadow:0 0 15px rgba(0,243,255,0.2); z-index:30; }
        #minimap-canvas { width:100%; height:100%; display:block; }
        .glitched-text { animation:glitch 1s linear infinite; }
        @keyframes glitch { 2%,64% { transform:translate(2px,0) skew(0deg); } 4%,60% { transform:translate(-2px,0) skew(0deg); } 62% { transform:translate(0,0) skew(5deg); } }
        .screen { position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(5,5,16,0.95); display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:50; backdrop-filter:blur(8px); pointer-events:auto; }
        .hidden { display:none !important; }
        #pause-menu, #market-screen { padding:40px; align-items: stretch; justify-content: flex-start; }
        .menu-container { display:flex; width:100%; height:90%; max-width:1200px; margin:0 auto; border:1px solid var(--neon-blue); background:rgba(10,10,20,0.95); box-shadow:0 0 30px rgba(0,0,0,0.8); flex-direction: column; }
        .menu-top-row { display: flex; flex: 2; border-bottom: 1px solid #333; }
        .menu-bottom-row { flex: 1; padding: 20px; display: flex; flex-direction: column; overflow: hidden; }
        .menu-col { flex:1; padding:30px; border-right:1px solid #333; display:flex; flex-direction:column; }
        .menu-col:last-child { border-right:none; }
        .menu-header { font-size:1.5rem; color:var(--neon-blue); border-bottom:2px solid var(--neon-blue); padding-bottom:10px; margin-bottom:20px; }
        .info-row { margin-bottom:15px; font-size:0.9rem; line-height:1.4; }
        .key-badge { display:inline-block; border:1px solid #666; padding:2px 6px; border-radius:2px; color:var(--neon-yellow); background:#222; margin-right:5px; }
        .class-grid, .diff-grid { display:grid; gap:20px; margin-top:30px; }
        .class-grid { grid-template-columns:repeat(2,1fr); }
        .diff-grid { grid-template-columns:repeat(4,1fr); gap:15px; }
        .card { border:1px solid #444; padding:20px; width:220px; cursor:pointer; transition:0.3s; background:rgba(20,20,30,0.6); text-align:left; position:relative; overflow:hidden; }
        .card:hover { border-color:var(--neon-green); background:rgba(0,255,65,0.05); transform:scale(1.02); box-shadow:0 0 20px rgba(0,255,65,0.2); }
        button { background:transparent; border:2px solid var(--neon-green); color:var(--neon-green); padding:15px 40px; font-size:1.5rem; font-family:'Share Tech Mono'; cursor:pointer; transition:0.2s; margin-top:20px; box-shadow:0 0 10px var(--neon-green); text-transform: uppercase; }
        button:hover { background:var(--neon-green); color:black; box-shadow:0 0 30px var(--neon-green); }
        #upgrade-container { display:flex; gap:20px; margin-top:20px; flex-wrap:wrap; justify-content:center; max-width:900px; }
        .upgrade-card { background:rgba(10,10,20,0.95); border:1px solid var(--neon-blue); width:220px; padding:20px; cursor:pointer; transition:0.2s; display:flex; flex-direction:column; align-items:center; text-align:center; box-shadow:0 0 10px rgba(0,243,255,0.2); position:relative; overflow: hidden;}
        .upgrade-card:hover { transform:translateY(-10px); box-shadow:0 0 30px var(--neon-blue); border-color:white; background:rgba(20,20,40,1); }
        .upgrade-tag { font-size:0.7rem; padding:2px 6px; border:1px solid currentColor; border-radius:4px; margin-bottom:5px; opacity:0.8; }
        .class-bonus { margin-top:10px; font-size:0.8rem; color:var(--neon-yellow); border-top:1px dashed #444; padding-top:5px; width:100%; font-style:italic; }
        #heat-ui { position:absolute; bottom:120px; left:50%; transform:translateX(-50%); width:300px; text-align:center; pointer-events:none; }
        #heat-bar-container { width:100%; height:16px; background:#111; border:1px solid #555; position:relative; overflow:hidden; transform:skew(-20deg); }
        #heat-bar-fill { height:100%; background:linear-gradient(90deg,var(--neon-yellow),#ff8800); width:0%; box-shadow:0 0 15px var(--neon-yellow); }
        #cool-minigame { width:100%; height:24px; background:#111; border:1px solid white; position:relative; margin-top:8px; display:none; transform:skew(-20deg); }
        #sweet-spot { position:absolute; height:100%; background:rgba(255,255,255,0.9); width:20%; left:40%; }
        #cool-cursor { position:absolute; height:120%; top:-10%; width:6px; background:var(--neon-red); left:0%; }
        .hazard-warning { position:absolute; top:20%; width:100%; text-align:center; font-size:3rem; color:var(--neon-red); background:rgba(0,0,0,0.6); padding:20px; display:none; z-index:40; animation:flash 0.5s infinite; text-shadow:0 0 20px var(--neon-red); }
        @keyframes flash { 0%,100% { opacity:1; } 50% { opacity:0.5; } }
        .wave-progress-text { font-size: 0.8rem; color: #aaa; margin-left: 5px; }
        
        /* Database Styles */
        #database-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 10px; overflow-y: auto; height: 100%; }
        .db-card { border: 1px solid #333; background: #111; padding: 10px; font-size: 0.8rem; color: #888; transition: 0.2s; display: flex; flex-direction: column; }
        .db-card.unlocked { border-color: var(--neon-blue); color: white; background: rgba(0, 243, 255, 0.1); }
        .db-card.unlocked:hover { background: rgba(0, 243, 255, 0.2); transform: translateY(-2px); }
        .db-title { font-weight: bold; margin-bottom: 5px; color: inherit; }
        .db-desc { font-size: 0.7rem; line-height: 1.2; flex: 1; }
        .db-type { font-size: 0.6rem; text-transform: uppercase; margin-bottom: 5px; color: #555; }
        .db-card.unlocked .db-type { color: var(--neon-yellow); }

        /* Market Styles */
        #market-items { display: flex; gap: 20px; justify-content: center; margin-top: 20px; }
        .market-card { background: rgba(10, 20, 10, 0.95); border: 1px solid var(--neon-green); width: 220px; padding: 20px; cursor: pointer; display: flex; flex-direction: column; align-items: center; text-align: center; transition: 0.2s; }
        .market-card:hover { transform: translateY(-5px); box-shadow: 0 0 20px var(--neon-green); border-color: white; }
        .market-card.cursed { border-color: var(--neon-red); background: rgba(30, 10, 10, 0.95); }
        .market-card.cursed:hover { box-shadow: 0 0 20px var(--neon-red); }
        .item-icon { font-size: 2rem; margin-bottom: 10px; }
        .item-price { margin-top: auto; font-weight: bold; color: var(--neon-yellow); }
        .item-cost-hum { font-size: 0.8rem; color: var(--neon-blue); margin-top: 2px; }
        .item-cost-hum.danger { color: var(--neon-red); animation: flash 1s infinite; }
    </style>
</head>
<body>
<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>
    <div class="vignette"></div>
    <div id="hazard-msg" class="hazard-warning">WARNING: TRAFFIC DETECTED</div>
    <div id="ui-layer">
        <div class="top-bar">
            <div class="stats-box">
                <div>TIME: <span id="timer" style="color:#fff; font-weight:bold;">00:00</span></div>
                <div>KILL: <span id="kill-count" style="color:var(--neon-red);">0</span></div>
                <div>CREDITS: <span id="credit-count" style="color:var(--neon-yellow);">0</span> ¬•</div>
                <div>
                    LVL: <span id="level" style="color:var(--neon-green);">1</span>
                    <div class="xp-bar-container"><div id="xp-bar-fill" class="xp-bar-fill"></div></div>
                </div>
                <div>
                    WAVE: <span id="wave-display" style="color:var(--neon-yellow); font-weight:bold;">1/3</span>
                    <span id="wave-progress" class="wave-progress-text">(0/0)</span>
                </div>
                <div id="difficulty-display" style="font-size:0.8rem; margin-top:5px; font-weight:bold;"></div>
                <div class="biome-indicator">LOC: <span id="biome-name">THE SPRAWL</span></div>
            </div>
            <div class="status-bars-container stats-box">
                <div class="bar-label"><span>INTEGRITY (HP)</span><span id="hp-text" style="color:var(--neon-green)">100/100</span></div>
                <div class="bar-bg">
                    <div id="hp-bar-fill" class="bar-fill" style="width:100%;"></div>
                    <div id="shield-bar-fill"></div>
                </div>
                <div class="bar-label"><span>HUMANITY</span><span id="humanity-status" style="color:var(--neon-blue)">STABLE</span></div>
                <div class="bar-bg"><div id="humanity-bar-fill" class="bar-fill" style="width:100%;"></div></div>
            </div>
        </div>
        <div id="boss-ui">
            <div id="boss-name" class="boss-name">BOSS</div>
            <div class="bar-bg" style="height:20px; border-color:var(--neon-red);"><div id="boss-bar-fill" class="bar-fill" style="width:100%;"></div></div>
        </div>
        <div id="heat-ui">
            <div id="heat-msg" style="margin-bottom:5px; font-weight:bold; text-shadow:0 0 5px black; letter-spacing:2px;"></div>
            <div id="heat-bar-container"><div id="heat-bar-fill"></div></div>
            <div id="cool-minigame"><div id="sweet-spot"></div><div id="cool-cursor"></div></div>
        </div>
        <div class="skill-cooldown" id="skill-box">
            <div id="skill-cd-overlay" class="skill-overlay"></div>
            <div class="skill-info"><span class="skill-key">SHIFT</span><span id="skill-timer" class="skill-timer">READY</span></div>
        </div>
        <div id="minimap-container"><canvas id="minimap-canvas"></canvas></div>
    </div>

    <!-- Screens -->
    <div id="difficulty-screen" class="screen">
        <h1>NEON NECROSIS</h1><p style="color:var(--neon-blue);">ÈÄâÊã©ÂçèËÆÆÈöæÂ∫¶ / SELECT PROTOCOL</p>
        <div class="diff-grid" id="diff-grid"></div>
    </div>
    <div id="start-screen" class="screen hidden">
        <h1>NEON NECROSIS</h1><p style="color:var(--neon-blue);">ÈÄâÊã©‰Ω†ÁöÑË∫´‰ªΩ / CHOOSE YOUR EDGERUNNER</p>
        <div class="class-grid" id="class-grid"></div>
        <div style="margin-top:30px; font-size:0.8rem; color:#888;">CONTROLS: [WASD] ÁßªÂä® | [SPACE] Êï£ÁÉ≠/ÂÆåÁæéË£ÖÂ°´ | [SHIFT] ËÅå‰∏öÊäÄËÉΩ | [ESC] ÊöÇÂÅú</div>
        <button onclick="backToDifficulty()" style="font-size:1rem; padding:10px 20px; border-color:#666; color:#aaa;">BACK</button>
    </div>
    <div id="pause-menu" class="screen hidden">
        <h2 style="color:var(--neon-blue); margin-bottom: 10px;">SYSTEM PAUSED</h2>
        <div class="menu-container">
            <div class="menu-top-row">
                <div class="menu-col">
                    <div class="menu-header">STATUS</div>
                    <div class="info-row">Class: <b id="menu-class-name" style="color:var(--neon-blue)">UNKNOWN</b></div>
                    <div id="stats-display" style="font-size:0.8rem; color:#aaa; display:grid; grid-template-columns:1fr 1fr; gap:5px;"></div>
                    <div class="menu-header" style="margin-top:20px;">INSTALLED</div>
                    <div id="menu-upgrade-list" style="overflow-y:auto; flex:1;"></div>
                </div>
                <div class="menu-col">
                    <div class="menu-header">CONTROLS</div>
                    <div class="info-row"><span class="key-badge">WASD</span> Move</div>
                    <div class="info-row"><span class="key-badge">SPACE</span> Active Reload / Cooling</div>
                    <div class="info-row"><span class="key-badge">SHIFT</span> Class Skill</div>
                    <div class="info-row" style="margin-top:auto;"><button class="resume-btn" onclick="togglePause()">RESUME</button></div>
                    <div class="info-row"><button class="restart-btn" onclick="restartGame()">REBOOT</button></div>
                </div>
            </div>
            <div class="menu-bottom-row">
                <div class="menu-header" style="font-size: 1rem; margin-bottom: 10px;">Êïå‰∫∫ÂõæÈâ¥ / ENEMY DATABASE</div>
                <div id="database-grid"></div>
            </div>
        </div>
    </div>
    <div id="levelup-screen" class="screen hidden">
        <h2 style="color:var(--neon-green);">SYSTEM UPGRADE AVAILABLE</h2>
        <div id="upgrade-container"></div>
    </div>
    <div id="market-screen" class="screen hidden">
        <h2 style="color:var(--neon-green);">BLACK MARKET ACCESS</h2>
        <p style="color:#888; margin-bottom: 20px;">UNAUTHORIZED SIGNAL DETECTED</p>
        <div class="stats-box" style="margin-bottom: 20px; display: flex; gap: 20px;">
            <div style="color:var(--neon-yellow)">CREDITS: <span id="market-credits">0</span> ¬•</div>
            <div style="color:var(--neon-blue)">HUMANITY: <span id="market-humanity">100</span></div>
        </div>
        <div id="market-items"></div>
        <div style="margin-top: 30px;">
            <button onclick="refreshMarket()" style="border-color:var(--neon-yellow); color:var(--neon-yellow); font-size: 1rem; padding: 10px 20px;">[R] REFRESH (<span id="refresh-cost">50</span>¬•)</button>
            <button onclick="closeMarket()" style="border-color:var(--neon-red); color:var(--neon-red); font-size: 1rem; padding: 10px 20px; margin-left: 20px;">[ESC] LEAVE</button>
        </div>
    </div>
    <div id="gameover-screen" class="screen hidden">
        <h1 style="color:var(--neon-red)" class="glitched-text">FLATLINED</h1>
        <p>ÁîüÂ≠òÊó∂Èó¥: <span id="final-time"></span></p>
        <p>ÂáªÊùÄÊï∞: <span id="final-kills"></span></p>
        <button onclick="restartGame()">REBOOT SYSTEM</button>
    </div>
</div>

<script>
    const getDist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const mmCtx = document.getElementById('minimap-canvas').getContext('2d');
    const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    document.getElementById('minimap-canvas').width = 160; document.getElementById('minimap-canvas').height = 160;

    const DIFFICULTIES = {
        easy:   { name: "ÁÆÄÂçïÊ®°Âºè", hp:0.8, dmg:0.8, speed:0.9, spawn:0.8, color:"#00ff41", trainDeath: false },
        normal: { name: "Ê†áÂáÜÊ®°Âºè", hp:1.0, dmg:1.0, speed:1.0, spawn:1.0, color:"#00f3ff", trainDeath: false },
        hard:   { name: "ÊåëÊàòÊ®°Âºè", hp:1.5, dmg:1.5, speed:1.2, spawn:1.3, color:"#ff003c", trainDeath: false },
        expert: { name: "Âú∞Áã±Ê®°Âºè", hp:2.5, dmg:2.0, speed:1.4, spawn:1.6, color:"#bc13fe", trainDeath: true }
    };

    const ENEMY_DATA = {
        'hound': { name: 'Cyber-Hound', desc: 'È´òÈÄüÁßªÂä®Ôºå‰ºöËØïÂõæÂåÖÊäÑÂà∞‰Ω†Ë∫´ÂêéÂèëÂä®ÊîªÂáª„ÄÇ', hp: 40, speed: 140, color: '#888', size: 12, xp: 2, credits: 2, ai: 'flank', shape: 'rect' },
        'junkie': { name: 'Junkie', desc: 'Âπ≥Êó∂ÁºìÊÖ¢ÔºåË°ÄÈáè‰Ωé‰∫é50%Êó∂ÁãÇÊö¥Âä†ÈÄü„ÄÇ', hp: 50, speed: 50, color: '#00aa00', size: 14, xp: 1, credits: 1, ai: 'berserk', shape: 'circle' },
        'shielder': { name: 'Riot Shielder', desc: 'ÊâãÊåÅÁõæÁâåÔºåÊ≠£Èù¢Ê†ºÊå°ÊâÄÊúâ‰º§ÂÆ≥„ÄÇËØ∑ÁªïÂêéÊîªÂáª„ÄÇ', hp: 120, speed: 30, color: '#0033cc', size: 20, xp: 3, credits: 5, ai: 'shield', shape: 'square' },
        'molotov': { name: 'Molotov Punk', desc: 'ÊäïÊé∑ÁáÉÁÉßÁì∂ÔºåÂà∂ÈÄ†ÊåÅÁª≠‰º§ÂÆ≥ÁöÑÁÅ´Êµ∑„ÄÇ', hp: 35, speed: 70, color: '#ffff00', size: 14, xp: 2, credits: 3, ai: 'range_aoe', shape: 'triangle' },
        'drone_sec': { name: 'Sec-Drone', desc: 'ÊàêÁæ§ÁªìÈòüÔºåÂõ¥Áªï‰Ω†È£ûË°åÂπ∂Â∞ÑÂáª„ÄÇ', hp: 25, speed: 110, color: '#ffffff', size: 10, xp: 1, credits: 2, ai: 'swarm', shape: 'x' },
        'drone_med': { name: 'Medi-Drone', desc: '‰∏çÊîªÂáªÔºå‰∏ìÊ≥®‰∫éÊ≤ªÁñóÂèó‰º§ÁöÑÁ≤æÈîêÊïå‰∫∫„ÄÇ', hp: 30, speed: 100, color: '#00ffaa', size: 12, xp: 2, credits: 3, ai: 'healer', shape: 'cross' },
        'sniper': { name: 'Corp Sniper', desc: 'Ë∂ÖËøúË∑ùÁ¶ªÈîÅÂÆöÔºåÁ∫¢Á∫øÂèòÂÆûÂêéÈÄ†ÊàêÂ∑®È¢ù‰º§ÂÆ≥„ÄÇ', hp: 45, speed: 20, color: '#ff0000', size: 14, xp: 3, credits: 10, ai: 'sniper', shape: 'diamond' },
        'barrier': { name: 'Barrier Unit', desc: 'Â±ïÂºÄÂäõÂú∫Êä§ÁõæÔºå‰øùÊä§ËåÉÂõ¥ÂÜÖÁöÑÂèãÂÜõ„ÄÇÂáªÁ†¥ÂÆÉÔºÅ', hp: 200, speed: 15, color: '#008888', size: 25, xp: 5, credits: 15, ai: 'barrier', shape: 'hexagon' },
        'bit_eater': { name: 'Bit-Eater', desc: 'ÈöêÂΩ¢Âçï‰ΩçÔºåÂè™ÊúâÂú®ÊîªÂáªÂâç‰∏ÄÂàªÊâç‰ºöÊòæÂΩ¢„ÄÇ', hp: 60, speed: 130, color: '#000', size: 15, xp: 3, credits: 4, ai: 'stealth', shape: 'glitch' },
        'replicator': { name: 'Replicator', desc: 'Ë¢´ÊëßÊØÅÊó∂‰ºöÂàÜË£ÇÊàê‰∏§‰∏™ËæÉÂ∞èÁöÑ‰∏™‰Ωì„ÄÇ', hp: 80, speed: 60, color: '#bc13fe', size: 18, xp: 4, credits: 6, ai: 'split', shape: 'poly' },
        'logic_bomb': { name: 'Logic Bomb', desc: 'ÂÜ≤Âêë‰Ω†Âπ∂ÂêØÂä®ÂÄíËÆ°Êó∂ÔºåÈöèÂêéÂ§ßËåÉÂõ¥Ëá™ÁàÜ„ÄÇ', hp: 50, speed: 160, color: '#ff003c', size: 16, xp: 2, credits: 5, ai: 'suicide', shape: 'skull' },
        'leech': { name: 'Data Leech', desc: 'Â≠òÂú®Êó∂Âπ≤Êâ∞Á≥ªÁªüÔºå‰Ωø‰Ω†Êó†Ê≥ïËá™ÁÑ∂Êï£ÁÉ≠ÊàñÂÜ∑Âç¥ÊäÄËÉΩ„ÄÇ', hp: 100, speed: 30, color: '#004400', size: 20, xp: 5, credits: 8, ai: 'debuff', shape: 'jelly' },
        'boss_tank': { name: 'MECH-OGRE', desc: 'Ë¥´Ê∞ëÁ™üÈú∏‰∏ª„ÄÇ', hp: 800, speed: 50, color: '#ff0000', size: 60, xp: 50, credits: 500, ai: 'boss', shape: 'boss' },
        'boss_exec': { name: 'EXECUTIONER', desc: 'ÂÖ¨Âè∏Â§ÑÂàëËÄÖ„ÄÇ', hp: 1200, speed: 60, color: '#fcee0a', size: 50, xp: 100, credits: 600, ai: 'boss', shape: 'boss' },
        'boss_core': { name: 'MAINFRAME', desc: 'AIÊ†∏ÂøÉ„ÄÇ', hp: 2000, speed: 40, color: '#00ff41', size: 80, xp: 200, credits: 800, ai: 'boss', shape: 'boss' }
    };

    const MARKET_ITEMS = [
        // Type A: Military Implants
        { id: 'sec_heart', name: 'Á¨¨‰∫åÂøÉËÑè', type: 'A', rarity: 'legendary', cost: 800, hum: 25, desc: 'Â§çÊ¥ª: Ê≠ª‰∫°Êó∂ÊÅ¢Â§ç50%Ë°ÄÈáèÂπ∂Êó†Êïå3Áßí', effect: p => p.stats.revive = true, icon: 'ü´Ä' },
        { id: 'kiroshi', name: 'Ê≠ßË∑ØÂè∏‰πâÁúº', type: 'A', rarity: 'epic', cost: 500, hum: 15, desc: 'Âº±ÁÇπÁúãÁ†¥: Êö¥ÂáªÁéá+10%, Êö¥‰º§250%', effect: p => { p.stats.critRate += 0.1; p.stats.critDmg = 2.5; }, icon: 'üëÅÔ∏è' },
        { id: 'gorilla', name: 'Â§ßÁå©Áå©ÊâãËáÇ', type: 'A', rarity: 'rare', cost: 400, hum: 20, desc: 'ÂèóÂà∞ËøëÊàòÊîªÂáªÊó∂ÈáäÊîæÈúáÊ≥¢ (CD:5s)', effect: p => p.stats.reactiveArmor = true, icon: 'ü¶æ' },
        { id: 'nano_leech', name: 'Á∫≥Á±≥Âê∏Ë°ÄËô´', type: 'A', rarity: 'epic', cost: 600, hum: 18, desc: 'Âê∏Ë°Ä: ÈÄ†Êàê‰º§ÂÆ≥ÁöÑ3%ËΩ¨Âåñ‰∏∫ÁîüÂëΩ', effect: p => p.stats.lifesteal += 0.03, icon: 'üß¨' },
        { id: 'smart_link', name: 'Êô∫ËÉΩËøûÊé•', type: 'A', rarity: 'rare', cost: 350, hum: 10, desc: 'ÊâÄÊúâÂ≠êÂºπËé∑ÂæóËá™Âä®ËøΩË∏™', effect: p => p.stats.tracking = true, icon: 'üéØ' },
        { id: 'sub_armor', name: 'ÁöÆ‰∏ãÊä§Áî≤', type: 'A', rarity: 'common', cost: 250, hum: 8, desc: 'Á°¨Âåñ: Âõ∫ÂÆöÂáè‰º§ +3', effect: p => p.stats.flatDmgReduc = (p.stats.flatDmgReduc||0) + 3, icon: 'üõ°Ô∏è' },

        // Type B: Consumables
        { id: 'immuno', name: 'ÂÖçÁñ´ÊäëÂà∂ÂâÇ', type: 'B', rarity: 'common', cost: 150, hum: -20, desc: 'ÁêÜÊô∫ÊÅ¢Â§ç: Á´ãÂç≥ÊÅ¢Â§ç 20 ÁÇπ‰∫∫ÊÄß', effect: p => p.humanity = Math.min(100, p.humanity + 20), icon: 'üíâ' },
        { id: 'battery', name: 'ÈªëÂ∏ÇÁîµÊ±†', type: 'B', rarity: 'common', cost: 100, hum: 0, desc: 'ÂÖÖËÉΩ: ÈáçÁΩÆÊäÄËÉΩ‰∏éÁÉ≠Èáè', effect: p => { p.skillCd = 0; p.weapon.heat = 0; }, icon: '‚ö°' },
        { id: 'stim', name: 'ÊàòÊñóÂÖ¥Â•ãÂâÇ', type: 'B', rarity: 'common', cost: 120, hum: 5, desc: 'ÁàÜÂèë: 30ÁßíÂÜÖÁßªÈÄü+40% ÊîªÈÄü+30%', effect: p => { p.speed *= 1.4; p.weapon.fireRate /= 1.3; setTimeout(()=>{ p.speed/=1.4; p.weapon.fireRate*=1.3; }, 30000); }, icon: 'üíä' },
        { id: 'repair', name: 'Á∫≥Á±≥‰øÆÂ§çÂâÇ', type: 'B', rarity: 'rare', cost: 200, hum: 0, desc: 'Ê≤ªÁñó: ÊÅ¢Â§ç 100% ÁîüÂëΩÂÄº', effect: p => p.hp = p.maxHp, icon: 'üîß' },

        // Type C: Cursed
        { id: 'glass', name: 'ÁéªÁíÉÂ§ßÁÇÆ', type: 'C', rarity: 'cursed', cost: 50, hum: 40, desc: '‰º§ÂÆ≥ +200%, ÊúÄÂ§ßÁîüÂëΩÈîÅÂÆö‰∏∫ 1', effect: p => { p.weapon.damage *= 3; p.maxHp = 1; p.hp = 1; }, icon: 'üíÄ' },
        { id: 'devil', name: 'ÊÅ∂È≠îÂ•ëÁ∫¶', type: 'C', rarity: 'cursed', cost: 0, hum: 50, desc: 'Ëé∑Âæó 2000 ÈáëÂ∏Å, Êâ£Èô§ 50 ‰∫∫ÊÄß', effect: p => p.credits += 2000, icon: 'üí∞' },
        { id: 'ballast', name: 'ÈáçÂûãÂéãËà±', type: 'C', rarity: 'cursed', cost: 100, hum: 10, desc: '‰º§ÂÆ≥+50%, Êä§Áî≤+20, ÁßªÈÄü-40%', effect: p => { p.weapon.damage *= 1.5; p.stats.flatDmgReduc = (p.stats.flatDmgReduc||0) + 20; p.speed *= 0.6; }, icon: 'üêå' },
        { id: 'overload', name: 'ËøáËΩΩÊ†∏ÂøÉ', type: 'C', rarity: 'cursed', cost: 100, hum: 20, desc: 'Êó†ÈôêËøáÁÉ≠‰∏çÂç°Â£≥, ‰ΩÜÂ∞ÑÂáªÊâ£ 2 HP', effect: p => p.stats.infiniteHeat = true, icon: 'üî•' }
    ];

    const CLASSES = {
        solo: { name:"Solo (Áã¨Áãº)", hpMulti:2.0, speedMulti:0.9, weapon:"shotgun", color:"#ffaa00", skillCd:10, baseStats:{regen:1.0, damage:1.2}, desc:"È´òË°ÄÈáèÔºåÈ´òÊä§Áî≤„ÄÇÊäÄËÉΩ: ÊÄíÊ∞îÂÆ£Ê≥Ñ (ÂáªÈÄÄ)" },
        netrunner: { name:"Netrunner (ÈªëÂÆ¢)", hpMulti:0.7, speedMulti:1.0, weapon:"smart_pistol", color:"#bc13fe", skillCd:15, baseStats:{xpRange:2.0, ricochet:1, tracking:true}, desc:"Ëá™Âä®ÁûÑÂáÜÔºåÈ´òÊãæÂèñ„ÄÇÊäÄËÉΩ: Á≥ªÁªüÂ¥©Ê∫É (ÂÜªÁªì)" },
        samurai: { name:"Samurai (Ê≠¶Â£´)", hpMulti:1.2, speedMulti:1.3, weapon:"monowire", color:"#ff003c", skillCd:8, baseStats:{dodge:0.15, critRate:0.15, critDmg:2.0}, desc:"È´òÊú∫Âä®ÔºåËøëÊàò„ÄÇÊäÄËÉΩ: ÊñØÂÆâÂ®ÅÊñØÂù¶ (ÂÜ≤Âà∫)" },
        techie: { name:"Techie (ÊäÄÂ∏à)", hpMulti:1.0, speedMulti:0.9, weapon:"tesla", color:"#00ff41", skillCd:12, baseStats:{heatCapMulti:1.5, areaExplosionChance:0.1}, desc:"ÁÇÆÂè∞ÊîØÊè¥„ÄÇÊäÄËÉΩ: ÈÉ®ÁΩ≤Âì®ÂÖµÁÇÆÂè∞" }
    };

    const LEVEL_CONFIG = [
        { name:"THE SPRAWL", color:"#080808", grid:"#1a1a1a", hazard:null, waves:[
            {count:15,rate:1.5,types:['hound']},
            {count:25,rate:1.2,types:['hound','junkie']},
            {count:40,rate:0.9,types:['junkie','shielder','molotov']}
        ], boss:'boss_tank' },
        { name:"CORPO PLAZA", color:"#050515", grid:"#101030", hazard:"traffic", waves:[
            {count:20,rate:1.2,types:['drone_sec']},
            {count:35,rate:1.0,types:['drone_sec','drone_med']},
            {count:50,rate:0.7,types:['barrier','sniper','drone_sec']}
        ], boss:'boss_exec' },
        { name:"SERVER FARM", color:"#000800", grid:"#001a00", hazard:"steam", waves:[
            {count:30,rate:0.9,types:['bit_eater','leech']},
            {count:45,rate:0.7,types:['bit_eater','replicator']},
            {count:60,rate:0.5,types:['logic_bomb','replicator','bit_eater']}
        ], boss:'boss_core' }
    ];

    const UPGRADE_POOL = [
        // Same as before
        { id:'kernel_oc', name:'ÂÜÖÊ†∏Ë∂ÖÈ¢ë v1.0', tag:'Overclock', color:'#ff003c', cost:5, classes:['all'], desc:'Âü∫Á°Ä‰º§ÂÆ≥ +10%', effect:p=>p.weapon.damage*=1.1 },
        { id:'light_driver', name:'ËΩªÈáèÂåñÈ©±Âä®', tag:'Driver', color:'#fcee0a', cost:4, classes:['all'], desc:'ÁßªÂä®ÈÄüÂ∫¶ +8%', effect:p=>p.speed*=1.08 },
        { id:'magnet_hs', name:'Á£ÅÂäõÊè°ÊâãÂçèËÆÆ', tag:'Magnet', color:'#bc13fe', cost:3, classes:['all'], desc:'ÊãæÂèñËåÉÂõ¥ +25%', effect:p=>p.stats.xpRange*=1.25 },
        { id:'multi_cool', name:'Â§öÁ∫øÁ®ãÂÜ∑Âç¥', tag:'Cooling', color:'#00f3ff', cost:6, classes:['all'], desc:'ÊäÄËÉΩÂÜ∑Âç¥ -10%', effect:p=>p.stats.cooldownReduc+=0.1 },
        { id:'firewall', name:'Èò≤ÁÅ´Â¢ôË°•‰∏Å', tag:'Defense', color:'#00ff41', cost:6, classes:['all'], desc:'ÂèóÂà∞‰º§ÂÆ≥ -2 (ÊúÄ‰Ωé1)', effect:p=>p.stats.flatDmgReduc=(p.stats.flatDmgReduc||0)+2 },
        { id:'emerg_reboot', name:'Á¥ßÊÄ•ÈáçÂêØÂÆàÊä§', tag:'Recovery', color:'#00ff41', cost:8, classes:['all'], desc:'ÊÅ¢Â§ç 25% ÁîüÂëΩÔºå‰∏äÈôê +5%', effect:p=>{p.hp+=p.maxHp*0.25; p.maxHp*=1.05;} },
        // SOLO
        { id:'kinetic_shield', name:'Âä®ËÉΩÊä§Áõæ', tag:'Solo', color:'#ffaa00', cost:10, classes:['solo'], desc:'ÊØèÁßªÂä®500Á†ÅÁîüÊàêÊä§ÁõæÊäµÊå°‰∏ÄÊ¨°‰º§ÂÆ≥', effect:p=>{p.hooks.onMove = (d)=>{ p.stats.shieldCharge = (p.stats.shieldCharge||0)+d; if(p.stats.shieldCharge>500 && !p.shield){p.shield=true; playSound('powerup'); showText("SHIELD UP",p.x,p.y-50,'#00f3ff'); p.stats.shieldCharge=0;} }} },
        { id:'bulldozer', name:'Êé®ÂúüÊú∫ÂçèËÆÆ', tag:'Solo', color:'#ffaa00', cost:8, classes:['solo'], desc:'ÂÜ≤Âà∫ÊíûÂáªÈÄ†Êàê300%‰º§ÂÆ≥Âπ∂ÂáªÈ£û', effect:p=>{p.stats.dashDmgMult=3.0; p.stats.dashKnockback=true;} },
        // NETRUNNER
        { id:'logic_bomb', name:'ÈÄªËæëÁÇ∏Âºπ', tag:'Netrunner', color:'#bc13fe', cost:8, classes:['netrunner'], desc:'Êô∫ËÉΩÊ≠¶Âô®ÂáªÊùÄÊïå‰∫∫‰∫ßÁîüÁàÜÁÇ∏', effect:p=>{p.hooks.onKill = (e)=>{ if(p.weapon.type==='smart_pistol') createExplosion(e.x,e.y,20,'#bc13fe'); enemies.forEach(sub=>{if(getDist(e,sub)<100) takeDamage(sub, p.weapon.damage*0.5, false, 'explosion'); }); }} },
        { id:'viral_spread', name:'ÁóÖÊØíÊâ©Êï£', tag:'Netrunner', color:'#bc13fe', cost:9, classes:['netrunner'], desc:'Ë¢´ÂÜªÁªìÊïå‰∫∫Ê≠ª‰∫°Êó∂‰º†ÊüìÂÜªÁªì', effect:p=>{p.hooks.onKill = (e)=>{ if(e.frozen>0) { let closest=null, md=300; enemies.forEach(n=>{if(n!==e && getDist(n,e)<md){md=getDist(n,e); closest=n;}}); if(closest){closest.frozen=3; showText("SPREAD",closest.x,closest.y-20,'#bc13fe');} } }} },
        // SAMURAI
        { id:'flow_state', name:'ÂøÉÊµÅÁä∂ÊÄÅ', tag:'Samurai', color:'#ff003c', cost:7, classes:['samurai'], desc:'ÊùÄÊïåÂè†Âä†ÁßªÈÄü(ÊúÄÈ´ò+20%)', effect:p=>{p.hooks.onKill = ()=>{ p.stats.flowStacks=(p.stats.flowStacks||0)+1; if(p.stats.flowStacks>20) p.stats.flowStacks=20; p.stats.flowTimer=5.0; }} },
        { id:'iai_algo', name:'Â±ÖÂêàÁÆóÊ≥ï', tag:'Samurai', color:'#ff003c', cost:8, classes:['samurai'], desc:'ÂÅúÊâã2ÁßíÂêéÔºå‰∏ã‰∏ÄÊ¨°ÊîªÂáªÂøÖÁàÜ‰∏îÂèåÂÄç‰º§ÂÆ≥', effect:p=>{p.stats.iaiMode=true;} },
        // TECHIE
        { id:'static_field', name:'ÈùôÁîµÂú∫', tag:'Techie', color:'#00ff41', cost:7, classes:['techie'], desc:'Âë®Âõ¥150Á†ÅÊïå‰∫∫ÊØèÁßíÂèóÁîµÂáª‰º§ÂÆ≥', effect:p=>{p.stats.staticField=true;} },
        { id:'overload_pulse', name:'ËøáËΩΩËÑâÂÜ≤', tag:'Techie', color:'#00ff41', cost:9, classes:['techie'], desc:'Ê≠¶Âô®ËøáÁÉ≠Êó∂ÈáäÊîæÂÖ®Â±èÈúáÊ≥¢', effect:p=>{p.hooks.onOverheat = ()=>{ createShockwave(p.x,p.y,'#ff003c',800); enemies.forEach(e=>{ takeDamage(e, 50, false, 'explosion'); e.pushX=(e.x-p.x)*5; e.pushY=(e.y-p.y)*5; }); }} }
    ];

    let state = { isRunning:false, paused:false, lastTime:0, timeElapsed:0, kills:0, level:1, xp:0, nextLevelXp:10, width:0, height:0, shake:0, hitStop:0, difficulty:DIFFICULTIES.normal, levelIndex:0, waveIndex:0, waveSpawned:0, waveKilled:0, bossActive:false, spawnTimer:0, upgrades:[], globalTime:0, encounteredEnemies: new Set(), market:{active:false, x:0, y:0, timer:0, interact:0, items:[], refreshCost:50} };
    const camera = { x:0, y:0 };
    const player = { x:0, y:0, speed:180, hp:100, maxHp:100, humanity:100, credits:0, radius:12, color:'#fff', invincible:0, skillCd:0, maxSkillCd:10, angle:0, vx:0, vy:0, isDash:false, dashTimer:0, shield:false, stats:{}, weapon:{}, hooks:{}, lastAttackTime:0 };
    let enemies=[], bullets=[], particles=[], gems=[], credits=[], texts=[], turrets=[], hazards=[], boss=null;
    const keys = {};

    // --- AI Behaviors (from previous step) ---
    const AI_BEHAVIORS = {
        flank: (e, p, dt) => {
            const dist = getDist(e, p);
            const angleToPlayer = Math.atan2(p.y - e.y, p.x - e.x);
            if (dist > 150) { e.angle = angleToPlayer + Math.sin(state.globalTime * 2) * 0.5; } 
            else { e.angle = angleToPlayer; if (!e.lunge) { e.lunge = true; e.speed *= 2; } }
        },
        berserk: (e, p, dt) => {
            e.angle = Math.atan2(p.y - e.y, p.x - e.x);
            if (e.hp < e.maxHp * 0.5) { e.color = '#ff0000'; e.speed = 100; e.pushX *= 0.5; e.pushY *= 0.5; }
        },
        shield: (e, p, dt) => { e.angle = Math.atan2(p.y - e.y, p.x - e.x); },
        range_aoe: (e, p, dt) => {
            e.angle = Math.atan2(p.y - e.y, p.x - e.x); const dist = getDist(e, p);
            if (dist < 300) e.speed = -50; else if (dist > 400) e.speed = 70; else e.speed = 0;
            e.timer = (e.timer || 0) + dt;
            if (e.timer > 3) { e.timer = 0; hazards.push({ type: 'steam', x: p.x, y: p.y, radius: 80, life: 5 }); showText("FIRE!", e.x, e.y, '#ffa500'); }
        },
        swarm: (e, p, dt) => {
            const angleToPlayer = Math.atan2(p.y - e.y, p.x - e.x); e.angle = angleToPlayer + Math.PI/2;
            e.timer = (e.timer || 0) + dt;
            if (e.timer > 2) { bullets.push({ x:e.x, y:e.y, vx:Math.cos(angleToPlayer)*300, vy:Math.sin(angleToPlayer)*300, life:2, damage:5, color:'#00f3ff', type:'bullet' }); e.timer = 0; }
        },
        healer: (e, p, dt) => {
            let target = null; enemies.forEach(ally => { if (ally !== e && ally.hp < ally.maxHp) target = ally; });
            if (target) { e.angle = Math.atan2(target.y - e.y, target.x - e.x); target.hp = Math.min(target.maxHp, target.hp + 10*dt); ctx.strokeStyle = '#00ff00'; ctx.beginPath(); ctx.moveTo(e.x, e.y); ctx.lineTo(target.x, target.y); ctx.stroke(); } 
            else { e.angle = Math.atan2(p.y - e.y, p.x - e.x) + Math.PI; }
        },
        sniper: (e, p, dt) => {
            const dist = getDist(e, p); e.angle = Math.atan2(p.y - e.y, p.x - e.x);
            if (dist < 500) e.speed = -20; else e.speed = 0;
            e.timer = (e.timer || 0) + dt;
            if (e.timer > 2.0 && e.timer < 3.5) { ctx.strokeStyle = `rgba(255, 0, 0, ${(e.timer-2.0)})`; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(e.x, e.y); ctx.lineTo(p.x, p.y); ctx.stroke(); }
            if (e.timer > 3.5) { bullets.push({ x:e.x, y:e.y, vx:Math.cos(e.angle)*800, vy:Math.sin(e.angle)*800, life:2, damage:30, color:'#ff0000', type:'beam' }); e.timer = 0; playSound('shoot'); }
        },
        barrier: (e, p, dt) => {
            enemies.forEach(ally => { if (ally !== e && getDist(e, ally) < 150) ally.shield = true; });
            e.angle = Math.atan2(p.y - e.y, p.x - e.x);
        },
        stealth: (e, p, dt) => { const dist = getDist(e, p); e.angle = Math.atan2(p.y - e.y, p.x - e.x); if (dist > 200) e.alpha = 0.1; else e.alpha = 1.0; },
        suicide: (e, p, dt) => {
             e.angle = Math.atan2(p.y - e.y, p.x - e.x);
             if (getDist(e, p) < 100) { createExplosion(e.x, e.y, 50, '#ff0000'); takeDamage(e, 9999, false, 'suicide'); if (getDist(e, p) < 150 && p.invincible <= 0) { p.hp -= 40; p.invincible = 0.5; } }
        },
        debuff: (e, p, dt) => { e.angle = Math.atan2(p.y - e.y, p.x - e.x) + Math.PI; },
        boss: (e, p, dt) => { e.angle = Math.atan2(p.y - e.y, p.x - e.x); },
        default: (e, p, dt) => { e.angle = Math.atan2(p.y - e.y, p.x - e.x); }
    };

    function resize() { canvas.width=state.width=window.innerWidth; canvas.height=state.height=window.innerHeight; }
    window.addEventListener('resize', resize); resize();
    window.addEventListener('keydown', e=>{ keys[e.code]=true; if(e.code==='Escape'&&state.isRunning) togglePause(); if(state.isRunning&&!state.paused){ if(e.code==='Space') handleCooling(); if(e.code==='ShiftLeft') useSkill(); if(e.code==='KeyR' && document.getElementById('market-screen').style.display!=='none') refreshMarket(); } });
    window.addEventListener('keyup', e=>keys[e.code]=false);

    function initUI() {
        const dGrid = document.getElementById('diff-grid'); dGrid.innerHTML='';
        Object.keys(DIFFICULTIES).forEach(k => {
            const d = DIFFICULTIES[k];
            dGrid.innerHTML += `<div class="diff-card" style="border-color:${d.color}" onclick="selectDifficulty('${k}')"><div class="diff-title" style="color:${d.color}">${d.name}</div><div class="diff-stats">HP:${d.hp*100}% DMG:${d.dmg*100}%<br>SPD:${d.speed*100}% AMT:${d.spawn*100}%<br>${d.trainDeath?'<span style="color:red">TRAIN DEATH</span>':''}</div></div>`;
        });
        const cGrid = document.getElementById('class-grid'); cGrid.innerHTML='';
        Object.keys(CLASSES).forEach(k => {
            const c = CLASSES[k];
            cGrid.innerHTML += `<div class="class-card" onclick="selectClass('${k}')"><div class="class-title" style="color:var(--neon-blue)">${c.name}</div><div class="class-desc">${c.desc}</div></div>`;
        });
        document.getElementById('difficulty-screen').classList.remove('hidden');
    }

    function selectDifficulty(k) {
        state.difficulty = DIFFICULTIES[k];
        document.getElementById('difficulty-display').innerText = `DIFFICULTY: ${state.difficulty.name}`;
        document.getElementById('difficulty-display').style.color = state.difficulty.color;
        document.getElementById('difficulty-screen').classList.add('hidden');
        document.getElementById('start-screen').classList.remove('hidden');
    }
    function backToDifficulty() { document.getElementById('start-screen').classList.add('hidden'); document.getElementById('difficulty-screen').classList.remove('hidden'); }

    function selectClass(id) {
        const c = CLASSES[id]; player.classId=id; player.maxHp=100*c.hpMulti; player.hp=player.maxHp; player.baseSpeed=180*c.speedMulti; player.speed=player.baseSpeed; player.color=c.color; player.maxSkillCd=c.skillCd;
        player.stats={lifesteal:0, regen:0, dodge:0, critRate:0.05, critDmg:1.5, xpRange:1, xpBonus:1, penetration:0, ricochet:0, heatCapMulti:1, areaExplosionChance:0, areaExplosionDmgMult:0.5, areaExplosionRadius:100, cooldownReduc:0, tracking:false, ...c.baseStats};
        player.hooks={}; player.shield=false; player.credits = 0;
        setupWeapon(c.weapon);
        document.getElementById('menu-class-name').innerText = c.name;
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('ui-layer').classList.remove('hidden');
        initGame();
        state.isRunning=true; state.lastTime=performance.now();
        requestAnimationFrame(gameLoop);
    }

    function setupWeapon(t) {
        player.weapon = {type:t, heat:0, maxHeat:100, cooldown:0, isOverheated:false, isVenting:false, ventProgress:0, ventSpeed:1.5, spread:0.1, count:1, overclockTimer:0};
        const w = player.weapon;
        if(t==='smart_pistol') { w.damage=15; w.fireRate=0.25; w.range=450; w.projectileSpeed=500; w.spread=0.2; }
        else if(t==='shotgun') { w.damage=10; w.fireRate=0.8; w.range=350; w.count=5; w.spread=0.5; w.projectileSpeed=600; }
        else if(t==='monowire') { w.damage=35; w.fireRate=0.1; w.range=90; }
        else if(t==='tesla') { w.damage=8; w.fireRate=0.15; w.range=350; }
    }

    function initGame() {
        enemies=[]; bullets=[]; particles=[]; gems=[]; credits=[]; texts=[]; turrets=[]; hazards=[]; boss=null;
        state.timeElapsed=0; state.kills=0; state.level=1; state.xp=0; state.nextLevelXp=10; state.hitStop=0;
        state.levelIndex=0; state.waveIndex=0; state.waveSpawned=0; state.waveKilled=0; state.bossActive=false; state.spawnTimer=0;
        state.upgrades=[]; player.x=0; player.y=0; player.humanity=100; player.skillCd=0; player.lastAttackTime=0; player.credits = 0;
        state.encounteredEnemies = new Set();
        state.market = {active: false, x: 0, y: 0, timer: 0, interact: 0, items: [], refreshCost: 50};
        document.getElementById('menu-upgrade-list').innerHTML='<div style="text-align:center;color:#666">NONE</div>';
        document.getElementById('boss-ui').style.display='none';
    }

    // --- Black Market Logic ---
    function spawnMarket() {
        // Find a safe spot near player
        const angle = Math.random() * Math.PI * 2;
        const dist = 500;
        state.market.x = player.x + Math.cos(angle) * dist;
        state.market.y = player.y + Math.sin(angle) * dist;
        state.market.active = true;
        state.market.timer = 30; // 30 seconds duration
        state.market.interact = 0;
        showText("UNAUTHORIZED SIGNAL DETECTED", player.x, player.y - 100, '#00ff41');
        playSound('powerup');
    }

    function openMarket() {
        state.paused = true;
        generateMarketItems();
        updateMarketUI();
        document.getElementById('market-screen').classList.remove('hidden');
    }

    function generateMarketItems() {
        state.market.items = [];
        const pool = MARKET_ITEMS; // All items for now
        for(let i=0; i<4; i++) {
            const item = pool[Math.floor(Math.random() * pool.length)];
            state.market.items.push(item);
        }
    }

    function updateMarketUI() {
        document.getElementById('market-credits').innerText = player.credits;
        document.getElementById('market-humanity').innerText = player.humanity;
        document.getElementById('refresh-cost').innerText = state.market.refreshCost;
        
        const container = document.getElementById('market-items');
        container.innerHTML = '';
        
        state.market.items.forEach((item, index) => {
            const div = document.createElement('div');
            div.className = `market-card ${item.type === 'C' ? 'cursed' : ''}`;
            const canAfford = player.credits >= item.cost;
            const canBear = player.humanity > item.hum || item.hum <= 0; // Can buy if hum cost is negative (gain) or sufficient
            
            div.innerHTML = `
                <div class="item-icon">${item.icon}</div>
                <div style="font-weight:bold; color:${item.type==='C'?'var(--neon-red)':'var(--neon-blue)'}">${item.name}</div>
                <div style="font-size:0.8rem; color:#aaa; margin:5px 0;">${item.desc}</div>
                <div class="item-price" style="color:${canAfford?'var(--neon-yellow)':'var(--neon-red)'}">${item.cost} ¬•</div>
                <div class="item-cost-hum ${(!canBear || (player.humanity-item.hum < 20 && item.hum > 0)) ? 'danger' : ''}">${item.hum > 0 ? '-' + item.hum : '+' + Math.abs(item.hum)} Humanity</div>
            `;
            
            div.onclick = () => buyItem(item, index);
            container.appendChild(div);
        });
    }

    function buyItem(item, index) {
        if (player.credits >= item.cost) {
            // Humanity check? Allow going into psychosis, but warn visually
            player.credits -= item.cost;
            player.humanity -= item.hum; 
            if(player.humanity > 100) player.humanity = 100;
            
            // Apply Effect
            item.effect(player);
            
            // Remove from slot
            state.market.items.splice(index, 1); // Or replace with 'Sold Out'
            
            playSound('powerup'); // Ca-ching placeholder
            updateMarketUI();
            updateUpgradeList(); // If it adds to stats, maybe log it
        } else {
            playSound('jam');
        }
    }

    function refreshMarket() {
        if (player.credits >= state.market.refreshCost) {
            player.credits -= state.market.refreshCost;
            state.market.refreshCost += 50;
            generateMarketItems();
            updateMarketUI();
            playSound('powerup');
        } else {
            playSound('jam');
        }
    }

    function closeMarket() {
        document.getElementById('market-screen').classList.add('hidden');
        state.paused = false;
        state.market.active = false; // Drone leaves after use
        state.lastTime = performance.now();
        requestAnimationFrame(gameLoop);
    }

    function updateDatabaseUI() {
        const db = document.getElementById('database-grid');
        db.innerHTML = '';
        Object.keys(ENEMY_DATA).forEach(key => {
            const e = ENEMY_DATA[key];
            const unlocked = state.encounteredEnemies.has(key);
            const div = document.createElement('div');
            div.className = `db-card ${unlocked?'unlocked':''}`;
            if (unlocked) {
                div.innerHTML = `<div class="db-type">${e.ai}</div><div class="db-title">${e.name}</div><div class="db-desc">${e.desc}</div>`;
            } else {
                div.innerHTML = `<div class="db-title">???</div><div class="db-desc">Encounter to unlock</div>`;
            }
            db.appendChild(div);
        });
    }

    function togglePause() {
        if(document.getElementById('market-screen').classList.contains('hidden') === false) {
            closeMarket(); // ESC closes market
            return;
        }
        state.paused = !state.paused;
        const el = document.getElementById('pause-menu');
        if(state.paused) {
            document.getElementById('stats-display').innerHTML=`<div>DMG:${Math.round(player.weapon.damage)}</div><div>HP:${Math.round(player.hp)}/${Math.round(player.maxHp)}</div><div>CRIT:${Math.round(player.stats.critRate*100)}%</div><div>DODGE:${Math.round(player.stats.dodge*100)}%</div>`;
            updateUpgradeList();
            updateDatabaseUI();
            el.classList.remove('hidden');
        } else {
            el.classList.add('hidden'); state.lastTime=performance.now(); requestAnimationFrame(gameLoop);
        }
    }
    function restartGame() { location.reload(); }

    function handleCooling() {
        if (player.stats.infiniteHeat) {
            // Overload Core logic
            return; 
        }
        const w = player.weapon;
        if (!w.isVenting && w.heat>0 && !w.isOverheated) { w.isVenting=true; w.ventProgress=0; w.sweetSpotWidth=0.15+Math.random()*0.1; w.sweetSpotStart=0.3+Math.random()*0.4; }
        else if (w.isVenting) {
            if (w.ventProgress>=w.sweetSpotStart && w.ventProgress<=(w.sweetSpotStart+w.sweetSpotWidth)) {
                w.heat=0; w.isVenting=false; w.overclockTimer=5; showText("OVERCLOCK!",player.x,player.y-40,'#00ff41'); playSound('powerup'); createExplosion(player.x,player.y,20,'#00ff41');
            } else { w.isVenting=false; w.heat=Math.max(0,w.heat-15); showText("JAMMED",player.x,player.y-40,'#ff003c'); playSound('jam'); }
        }
    }

    function useSkill() {
        if (player.skillCd > 0 || player.jammed) return; 
        player.skillCd = player.maxSkillCd * (1 - player.stats.cooldownReduc);
        playSound('powerup'); showText("SKILL!", player.x, player.y-50, player.color);
        if (player.classId === 'solo') {
            createShockwave(player.x, player.y, '#ffaa00', 300);
            enemies.forEach(e => { if(getDist(e,player)<350) { e.pushX=(e.x-player.x)*2; e.pushY=(e.y-player.y)*2; takeDamage(e,50+player.weapon.damage*2,false,'skill'); }});
            state.shake=25;
        } else if (player.classId === 'netrunner') {
            enemies.forEach(e => { e.frozen=3; showText("HACKED",e.x,e.y-20,'#bc13fe'); takeDamage(e,20,false,'skill'); });
        } else if (player.classId === 'samurai') {
            player.isDash=true; player.invincible=1.0; player.dashTimer=0.5;
            player.vx = Math.cos(player.angle)*1200; player.vy = Math.sin(player.angle)*1200;
        } else if (player.classId === 'techie') {
            turrets.push({x:player.x, y:player.y, life:20, cooldown:0, range:300, damage:player.weapon.damage*0.8});
        }
    }

    function showLevelUp() {
        const c = document.getElementById('upgrade-container'); c.innerHTML = '';
        document.getElementById('levelup-screen').classList.remove('hidden');
        const pool = UPGRADE_POOL.filter(u => u.classes.includes('all') || u.classes.includes(player.classId));
        const opts = pool.sort(() => 0.5 - Math.random()).slice(0, 3);
        opts.forEach(u => {
            const d = document.createElement('div'); d.className = 'upgrade-card';
            const isClass = u.classes.includes(player.classId) && !u.classes.includes('all');
            if (isClass) { d.style.borderColor = 'var(--neon-yellow)'; d.style.boxShadow = '0 0 15px var(--neon-yellow)'; }
            d.innerHTML = `<span class="upgrade-tag" style="color:${u.color};border-color:${u.color}">${u.tag}</span><h3 style="color:${u.color};margin:5px 0">${u.name}</h3><p style="font-size:0.9rem;color:#ddd">${u.desc}</p><small style="color:#aaa;margin-top:auto">COST: ${u.cost} HUMANITY</small>${isClass?'<div class="class-bonus">‚òÖ CLASS EXCLUSIVE</div>':''}`;
            d.onclick = () => {
                u.effect(player); player.humanity -= u.cost; state.upgrades.push(u); updateUpgradeList();
                state.paused = false; document.getElementById('levelup-screen').classList.add('hidden');
                state.lastTime = performance.now(); requestAnimationFrame(gameLoop);
            };
            c.appendChild(d);
        });
    }

    function updateUpgradeList() {
        const l = document.getElementById('menu-upgrade-list');
        if(!state.upgrades.length) { l.innerHTML='<div style="text-align:center;color:#666">NONE</div>'; return; }
        l.innerHTML = state.upgrades.map(u => `<div class="upgrade-list-item"><span>${u.name}</span><span style="color:${u.color}">${u.tag}</span></div>`).join('');
    }

    function spawnEnemy(types) {
        const a = Math.random()*Math.PI*2; const d = Math.max(state.width,state.height)*0.8;
        const type = types[Math.floor(Math.random()*types.length)];
        const data = ENEMY_DATA[type];
        if (!state.encounteredEnemies.has(type)) state.encounteredEnemies.add(type);
        const scale = 1 + (state.levelIndex*0.5);
        enemies.push({ 
            id: type, x:player.x+Math.cos(a)*d, y:player.y+Math.sin(a)*d, 
            hp:data.hp*scale*state.difficulty.hp, maxHp:data.hp*scale*state.difficulty.hp, 
            speed:data.speed*state.difficulty.speed, color:data.color, size:data.size, xp:data.xp, credits: data.credits,
            ai:data.ai, shape:data.shape, pushX:0, pushY:0, frozen:0, angle:0, scale: 0.1, state: 0, timer: 0, shield: (data.ai === 'shielder' || data.ai === 'barrier')
        });
    }

    function spawnBoss(bossKey) {
        state.bossActive = true;
        const a = Math.random()*Math.PI*2; const d = 600;
        const data = ENEMY_DATA[bossKey];
        const hp = data.hp * state.difficulty.hp;
        if (!state.encounteredEnemies.has(bossKey)) state.encounteredEnemies.add(bossKey);
        boss = { 
            id: bossKey, x:player.x+Math.cos(a)*d, y:player.y+Math.sin(a)*d, 
            type:'boss', hp:hp, maxHp:hp, speed:data.speed*state.difficulty.speed, 
            size:data.size, color:data.color, name:data.name, credits: data.credits,
            pushX:0, pushY:0, frozen:0, angle:0, isBoss:true, ai:'boss', shape:'boss', scale: 0.1
        };
        enemies.push(boss);
        const bui = document.getElementById('boss-ui'); bui.style.display='block'; 
        document.getElementById('boss-name').innerText=boss.name; document.getElementById('boss-name').style.color=boss.color; document.getElementById('boss-bar-fill').style.backgroundColor=boss.color;
        showText("BOSS DETECTED", player.x, player.y-150, '#ff0000'); playSound('overheat');
    }

    function killEnemy(e) {
        state.kills++;
        if (!state.bossActive) state.waveKilled++;
        if(player.hooks.onKill) player.hooks.onKill(e);
        
        if (e.ai === 'split' && e.size > 10) {
            for(let i=0; i<2; i++) {
                enemies.push({
                    ...e, hp: e.maxHp*0.6, maxHp: e.maxHp*0.6, size: e.size*0.7, speed: e.speed*1.2,
                    x: e.x + (Math.random()-0.5)*20, y: e.y + (Math.random()-0.5)*20, scale: 1.0, ai: 'split_child' // prevent infinite split
                });
            }
        }

        if (e.isBoss) {
            boss = null; state.bossActive = false; document.getElementById('boss-ui').style.display = 'none';
            createExplosion(e.x, e.y, 50, e.color); showText("BOSS DEFEATED", player.x, player.y - 100, '#00ff41');
            state.levelIndex++; state.waveIndex = 0; state.waveSpawned = 0; state.waveKilled = 0;
            player.hp = player.maxHp; showText(state.levelIndex < LEVEL_CONFIG.length ? "BIOME COMPLETE - HEALED" : "LOOPING", player.x, player.y - 150, '#fff');
            spawnMarket(); // Guaranteed market after boss
            if (state.levelIndex >= LEVEL_CONFIG.length) state.levelIndex = 0;
        }

        gems.push({ x: e.x, y: e.y, val: e.xp }); 
        if (Math.random() < 0.2 || e.isBoss) credits.push({ x: e.x, y: e.y, val: e.credits }); // 20% chance for credits
        createExplosion(e.x, e.y, 15, e.color);
    }

    function takeDamage(e, amt, crit, source) {
        if(e.hp <= 0) return;
        if (e.shield && e.ai === 'shielder') {
             const angleToPlayer = Math.atan2(player.y - e.y, player.x - e.x);
             const angleDiff = Math.abs(normalizeAngle(angleToPlayer - e.angle));
             if (angleDiff < Math.PI/2) { showText("BLOCKED", e.x, e.y - 20, '#00f3ff', 12); return; }
        }

        e.hp -= amt; showText(Math.floor(amt), e.x, e.y, crit?'#fcee0a':'white', crit?24:16);
        e.scale = 1.3; if (crit || e.hp <= 0) state.hitStop = 0.05;
        
        if (source === 'weapon' && player.stats.lifesteal > 0 && player.hp < player.maxHp) {
            const heal = amt * player.stats.lifesteal * (player.stats.healEff || 1);
            player.hp = Math.min(player.maxHp, player.hp + heal);
        }
        if(source === 'weapon' && player.stats.areaExplosionChance>0 && Math.random()<player.stats.areaExplosionChance) {
            const r = player.stats.areaExplosionRadius;
            createShockwave(e.x, e.y, '#ff8800', r); state.shake=5;
            enemies.forEach(sub=>{ if(sub!==e && getDist(sub,e)<r) { sub.pushX += (sub.x-e.x)*2; sub.pushY += (sub.y-e.y)*2; takeDamage(sub, amt*player.stats.areaExplosionDmgMult, false, 'explosion'); }});
        }
        if(e.hp<=0) killEnemy(e);
    }

    function normalizeAngle(angle) { while (angle > Math.PI) angle -= Math.PI * 2; while (angle < -Math.PI) angle += Math.PI * 2; return angle; }

    function updateHazards(dt, lvl) {
        if(lvl.hazard === 'traffic' && Math.random()<0.005) {
            const y = player.y + (Math.random()-0.5)*500;
            hazards.push({type:'car', x:player.x-1200, y:y, w:200, h:60, vx:1800, life:2, warning:1});
            document.getElementById('hazard-msg').style.display='block'; setTimeout(()=>document.getElementById('hazard-msg').style.display='none',1000);
        } else if (lvl.hazard === 'steam' && Math.random()<0.01) {
            hazards.push({type:'steam', x:player.x+(Math.random()-0.5)*800, y:player.y+(Math.random()-0.5)*600, radius:120, life:5});
        }
        for(let i=hazards.length-1; i>=0; i--) {
            const h = hazards[i]; h.life-=dt;
            if(h.type==='car') {
                if(h.warning>0) h.warning-=dt;
                else {
                    h.x+=h.vx*dt;
                    if(Math.abs(player.x-h.x)<h.w/2 && Math.abs(player.y-h.y)<h.h/2 && player.invincible<=0) {
                        if(state.difficulty.trainDeath) { player.hp=0; gameOver(); }
                        else { 
                            let dmg = player.maxHp*0.5;
                            if(player.shield) { player.shield=false; dmg=0; showText("BLOCKED",player.x,player.y-50,'#00f3ff'); }
                            if(dmg>0) { player.hp-=dmg; player.invincible=1; state.shake=30; player.y+=(player.y>h.y?200:-200); playSound('hit'); showText("TRAIN HIT!",player.x,player.y-50,'#ff003c'); if(player.hp<=0) gameOver(); }
                        }
                    }
                    enemies.forEach(e=>{if(Math.abs(e.x-h.x)<h.w/2 && Math.abs(e.y-h.y)<h.h/2) { takeDamage(e, 9999, false, 'hazard'); }});
                }
            } else if(h.type==='steam') { if(getDist(player,h)<h.radius) player.speed=player.baseSpeed*0.5; }
            if(h.life<=0) hazards.splice(i,1);
        }
    }

    function fireTesla(target, dmg, idx, isCrit) {
        let chain=[target], curr=target;
        takeDamage(curr, dmg*(isCrit?player.stats.critDmg:1), isCrit, 'weapon');
        for(let i=0; i<3+player.stats.ricochet; i++) {
            let next=null, md=250;
            enemies.forEach(e=>{if(!chain.includes(e)){const d=getDist(e,curr); if(d<md){if(idx>0&&Math.random()<0.5)return; md=d; next=e;}}});
            if(next) { chain.push(next); takeDamage(next, dmg*0.8, false, 'weapon'); curr=next; } else break;
        }
        particles.push({type:'lightning', chain:chain.map(e=>({x:e.x,y:e.y})), life:0.15+idx*0.05, color:'#00f3ff'});
    }

    function spawnWaveEnemy(dt) {
        if(state.bossActive) return; 
        const currentLevel = LEVEL_CONFIG[state.levelIndex];
        if(state.levelIndex >= LEVEL_CONFIG.length) return;

        if(state.waveIndex >= currentLevel.waves.length) {
             if(!boss) spawnBoss(currentLevel.boss);
             return;
        }

        const currentWave = currentLevel.waves[state.waveIndex];
        if(state.waveKilled >= currentWave.count) {
             state.waveIndex++; state.waveSpawned = 0; state.waveKilled = 0;
             if(state.waveIndex < currentLevel.waves.length) {
                 showText("WAVE " + (state.waveIndex + 1), player.x, player.y - 100, '#00ff41');
                 if ((state.waveIndex + 1) % 2 === 0) spawnMarket(); // Chance for market
             } else { showText("WARNING: BOSS APPROACHING", player.x, player.y - 100, '#ff0000'); }
             return;
        }

        if(state.waveSpawned < currentWave.count) {
            state.spawnTimer -= dt;
            if(state.spawnTimer <= 0) {
                spawnEnemy(currentWave.types); state.waveSpawned++; state.spawnTimer = (1.0 / currentWave.rate) / state.difficulty.spawn;
            }
        }
    }

    function update(dt) {
        if (state.hitStop > 0) { state.hitStop -= dt; return; }

        spawnWaveEnemy(dt);
        
        // Market Logic
        if (state.market.active) {
            state.market.timer -= dt;
            if (state.market.timer <= 0) { state.market.active = false; showText("MARKET CLOSED", state.market.x, state.market.y - 50, '#aaa'); }
            else if (getDist(player, state.market) < 60) {
                state.market.interact += dt;
                if (state.market.interact > 2.0) { openMarket(); }
            } else {
                state.market.interact = Math.max(0, state.market.interact - dt);
            }
        }

        if (player.stats.regen>0 && player.hp<player.maxHp && player.humanity>20) player.hp += player.stats.regen*dt;
        if (player.skillCd>0) player.skillCd -= dt;
        if (player.stats.flowStacks > 0) { player.stats.flowTimer -= dt; if (player.stats.flowTimer <= 0) { player.stats.flowStacks = Math.max(0, player.stats.flowStacks - 1); player.stats.flowTimer = 0.5; } }
        
        if (player.stats.staticField) {
            enemies.forEach(e => { if (getDist(e, player) < 150) { takeDamage(e, 5 * dt, false, 'static'); if (Math.random() < 0.1) createExplosion(e.x, e.y, 1, '#00ff41'); } });
        }
        
        player.jammed = false;
        enemies.forEach(e => { if (e.ai === 'debuff') player.jammed = true; });
        if (player.jammed && Math.random() < 0.05) showText("JAMMED", player.x, player.y - 50, '#00aa00', 10);

        if (player.isDash) {
            player.dashTimer-=dt; player.x+=player.vx*dt; player.y+=player.vy*dt;
            enemies.forEach(e=>{ if(getDist(e,player)<60 && !e.hitByDash){ 
                let dmg = player.weapon.damage * (player.stats.dashDmgMult || 5);
                takeDamage(e, dmg, true, 'dash'); e.hitByDash=true; createExplosion(e.x,e.y,10,'#ff003c'); 
            }});
            if(player.dashTimer<=0) { player.isDash=false; enemies.forEach(e=>e.hitByDash=false); if(player.hooks.onDashEnd) player.hooks.onDashEnd(); }
        } else {
            let dx=0, dy=0; if(keys['KeyW']) dy--; if(keys['KeyS']) dy++; if(keys['KeyA']) dx--; if(keys['KeyD']) dx++;
            if(dx||dy) player.angle = Math.atan2(dy,dx);
            let spd = player.speed * (player.humanity<20 ? 1.4 : 1);
            if (player.stats.flowStacks) spd *= (1 + player.stats.flowStacks * 0.01);
            if(player.humanity<20) { player.hp-=dt*1.5; if(player.hp<=0) gameOver(); }
            if(dx||dy) { const l=Math.hypot(dx,dy); const moveDist = spd * dt; player.x+=dx/l*moveDist; player.y+=dy/l*moveDist; if(player.hooks.onMove) player.hooks.onMove(moveDist); }
        }
        camera.x += (player.x - state.width/2 - camera.x)*0.1; camera.y += (player.y - state.height/2 - camera.y)*0.1;

        const w = player.weapon; w.cooldown-=dt; if(w.overclockTimer>0) w.overclockTimer-=dt;
        if(!w.isOverheated && !w.isVenting) {
            if(w.type==='monowire' && w.cooldown<=0) {
                let hit=false;
                enemies.forEach(e=>{ if(getDist(e,player)<w.range) { 
                    let isCrit = Math.random() < player.stats.critRate;
                    if(player.stats.iaiMode) { isCrit=true; player.stats.iaiMode=false; }
                    let dmg = w.damage*(w.overclockTimer>0?1.5:1)*(isCrit?player.stats.critDmg:1);
                    if(player.stats.iaiMode) dmg *= 2;
                    takeDamage(e, dmg, isCrit, 'weapon'); hit=true; 
                }});
                if(hit) { w.heat+=2; playSound('shoot'); }
                w.cooldown = w.fireRate*(1-player.stats.cooldownReduc);
                player.lastAttackTime = state.globalTime;
            } else if (w.cooldown<=0) {
                let target=null, minD=Infinity; enemies.forEach(e=>{const d=getDist(e,player); if(d<minD){minD=d; target=e;}});
                if(target && minD<w.range) {
                    playSound('shoot');
                    player.lastAttackTime = state.globalTime;
                    let isCrit = Math.random() < player.stats.critRate;
                    if(player.stats.iaiMode) { isCrit=true; player.stats.iaiMode=false; }
                    let dmg = w.damage*(w.overclockTimer>0?1.5:1);
                    if(player.stats.zeroDay && target.hp < target.maxHp*0.25) dmg *= 2;
                    if (player.stats.infiniteHeat) { player.hp -= 2; } // Cursed item
                    const count = Math.max(1, w.count);
                    const angle = Math.atan2(target.y-player.y, target.x-player.x);
                    if(w.type==='tesla') {
                        for(let i=0; i<count; i++) fireTesla(target, dmg, i, isCrit);
                    } else { 
                        let spread = w.spread + (w.type==='smart_pistol'&&count>1 ? 0.2:0);
                        for(let i=0; i<count; i++) {
                            const a = angle + (count>1 ? (i-(count-1)/2)*spread : (w.type==='shotgun'?(Math.random()-0.5)*spread:0));
                            bullets.push({x:player.x, y:player.y, vx:Math.cos(a)*w.projectileSpeed, vy:Math.sin(a)*w.projectileSpeed, target:target, type:w.type==='shotgun'?'shell':'bullet', size:w.type==='shotgun'?4:2, life:0.6, damage:dmg, crit:isCrit, cDmg:player.stats.critDmg, pierce:player.stats.penetration, ricochet:player.stats.ricochet, homing:player.stats.tracking||w.type==='smart_pistol'});
                        }
                    }
                    const heatCost = (w.type==='shotgun'?20:10);
                    w.heat += heatCost * (w.overclockTimer>0?0.5:1);
                    w.cooldown = w.fireRate * (w.overclockTimer>0?0.5:1) * (1-player.stats.cooldownReduc);
                }
            }
        }
        
        if (!player.stats.iaiMode && state.globalTime - player.lastAttackTime > 2.0 && state.upgrades && state.upgrades.find(u=>u.id==='iai_algo')) {
            player.stats.iaiMode = true; showText("IAI READY", player.x, player.y-60, '#ff003c');
        }

        if(w.heat >= w.maxHeat*(player.stats.heatCapMulti||1) && !player.stats.infiniteHeat) { 
            w.heat=w.maxHeat*(player.stats.heatCapMulti||1); w.isOverheated=true; playSound('overheat'); 
            if(player.hooks.onOverheat) player.hooks.onOverheat();
            setTimeout(()=>{w.isOverheated=false; w.heat=0;},3000); 
        }
        if(w.isVenting) { w.ventProgress+=dt*w.ventSpeed; if(w.ventProgress>=1){w.isVenting=false; w.heat=Math.max(0,w.heat-20);} }
        else if(!w.isOverheated && w.heat>0 && w.cooldown<-0.2) w.heat = Math.max(0, w.heat-dt*10);

        const lvl = LEVEL_CONFIG[Math.min(state.levelIndex, LEVEL_CONFIG.length-1)];
        document.getElementById('biome-name').innerText = lvl.name;
        const currentWave = lvl.waves[Math.min(state.waveIndex, lvl.waves.length-1)];
        const waveTarget = currentWave ? currentWave.count : 0;
        const waveProgressStr = state.bossActive ? "(BOSS)" : `(${state.waveKilled}/${waveTarget})`;
        document.getElementById('wave-display').innerText = state.bossActive ? "BOSS" : `WAVE ${state.waveIndex+1}`;
        document.getElementById('wave-progress').innerText = waveProgressStr;
        document.getElementById('credit-count').innerText = player.credits;

        updateHazards(dt, lvl);
        
        turrets.forEach((t,i)=>{
            t.life-=dt; t.cooldown-=dt; t.angle+=dt;
            if(t.cooldown<=0) { let tgt=null; enemies.forEach(e=>{if(getDist(e,t)<t.range) tgt=e;}); if(tgt) { bullets.push({x:t.x,y:t.y,vx:(tgt.x-t.x)*3,vy:(tgt.y-t.y)*3,life:0.6,damage:t.damage,color:'#00ff41',type:'beam'}); t.cooldown=0.5; } }
            if(t.life<=0) { if(player.stats.turretExplode) createExplosion(t.x, t.y, 30, '#ff8800'); turrets.splice(i,1); }
        });

        for(let i=bullets.length-1; i>=0; i--) {
            const b = bullets[i]; b.life-=dt; b.x+=b.vx*dt; b.y+=b.vy*dt;
            if(b.homing && b.target && b.target.hp>0) {
                const a = Math.atan2(b.target.y-b.y, b.target.x-b.x); b.vx += Math.cos(a)*2000*dt; b.vy += Math.sin(a)*2000*dt;
                const s = Math.hypot(b.vx, b.vy); const ms = 600; b.vx=(b.vx/s)*ms; b.vy=(b.vy/s)*ms;
            }
            if(Math.random()<0.3) particles.push({x:b.x,y:b.y,vx:0,vy:0,life:0.2,color:player.color,size:2});
            if(b.life<=0) { bullets.splice(i,1); continue; }
            
            for(const e of enemies) {
                if(b.hitList && b.hitList.includes(e)) continue;
                if(getDist(b,e) < e.size+10) {
                    const critMult = b.crit ? player.stats.critDmg : 1;
                    takeDamage(e, b.damage * critMult, b.crit, 'weapon');
                    createExplosion(b.x, b.y, 3, player.color);
                    if(!b.hitList) b.hitList=[]; b.hitList.push(e);
                    if(b.pierce>0) { b.pierce--; b.damage*=0.8; }
                    else if(b.ricochet>0) { b.ricochet--; b.hitList=[]; let nt=null, md=400; enemies.forEach(ne=>{if(ne!==e && getDist(ne,b)<md) { md=getDist(ne,b); nt=ne; }}); if(nt) { const a=Math.atan2(nt.y-b.y,nt.x-b.x); const s=Math.hypot(b.vx,b.vy); b.vx=Math.cos(a)*s; b.vy=Math.sin(a)*s; } else { b.vx=-b.vx; b.vy=-b.vy; } } else { bullets.splice(i,1); }
                    break;
                }
            }
        }

        enemies.forEach(e => {
            if(e.hp<=0) return;
            if(e.frozen>0) { e.frozen-=dt; return; }
            AI_BEHAVIORS[e.ai || 'default'](e, player, dt);
            let sx=0, sy=0; enemies.forEach(o=>{ if(e!==o && getDist(e,o)<e.size*2) { const d=getDist(e,o)||1; sx+=(e.x-o.x)/d; sy+=(e.y-o.y)/d; }});
            e.pushX*=0.9; e.pushY*=0.9;
            e.x += (Math.cos(e.angle)*e.speed + sx*50 + e.pushX)*dt; e.y += (Math.sin(e.angle)*e.speed + sy*50 + e.pushY)*dt;
            if (e.scale && e.scale !== 1) { e.scale += (1 - e.scale) * 10 * dt; } else { e.scale = 1; }
            if(getDist(e,player) < player.radius+e.size) {
                if(player.invincible<=0) {
                    let dodged = Math.random()<player.stats.dodge; if(dodged && player.hooks.onDodge) player.hooks.onDodge();
                    if(dodged) { showText("DODGE",player.x,player.y-30,'#00f3ff'); player.invincible=0.2; }
                    else { 
                        let dmg = 10*state.difficulty.dmg;
                        if(player.stats.flatDmgReduc) dmg = Math.max(1, dmg - player.stats.flatDmgReduc);
                        if(player.shield) { player.shield=false; showText("BLOCKED",player.x,player.y-30,'#00f3ff'); dmg=0; }
                        if(dmg > 0) { player.hp -= dmg; player.invincible=0.5; state.shake=10; playSound('hit'); if(player.hp<=0) gameOver(); }
                    }
                }
            }
        });
        enemies = enemies.filter(e=>e.hp>0);

        gems.forEach((g,i)=>{
            if(getDist(player,g) < 120*(player.stats.xpRange||1)) { g.x+=(player.x-g.x)*8*dt; g.y+=(player.y-g.y)*8*dt; }
            if(getDist(player,g) < 20) {
                state.xp += g.val*(player.stats.xpBonus||1);
                if(player.humanity<20) player.hp=Math.min(player.maxHp, player.hp+2);
                if(player.hooks.onXp) player.hooks.onXp();
                if(state.xp >= state.nextLevelXp) { state.level++; state.xp-=state.nextLevelXp; state.nextLevelXp=Math.floor(state.nextLevelXp*1.5); state.paused=true; showLevelUp(); }
                gems.splice(i,1); playSound('pickup');
            }
        });
        
        credits.forEach((c,i)=>{
            if(getDist(player,c) < 120*(player.stats.xpRange||1)) { c.x+=(player.x-c.x)*8*dt; c.y+=(player.y-c.y)*8*dt; }
            if(getDist(player,c) < 20) {
                player.credits += c.val;
                credits.splice(i,1); playSound('pickup');
            }
        });

        particles.forEach((p,i)=>{
            p.life-=dt; if(p.type==='shockwave'){ /* handled in render */ } else { p.x+=p.vx*dt; p.y+=p.vy*dt; }
            if(p.life<=0) particles.splice(i,1);
        });
        texts.forEach((d,i)=>{ d.y-=30*dt; d.life-=dt; if(d.life<=0) texts.splice(i,1); });
        if(player.invincible>0) player.invincible-=dt;
    }

    function render() {
        const t = state.globalTime;
        const lvl = LEVEL_CONFIG[Math.min(state.levelIndex, LEVEL_CONFIG.length-1)];
        if(player.humanity<20 && Math.random()<0.05) { ctx.fillStyle='#200'; ctx.fillRect(0,0,state.width,state.height); }
        else { ctx.fillStyle=lvl.color; ctx.fillRect(0,0,state.width,state.height); drawGrid(ctx, lvl, t); }
        if(state.shake>0) { ctx.save(); ctx.translate((Math.random()-0.5)*state.shake, (Math.random()-0.5)*state.shake); state.shake*=0.9; } else ctx.save();
        ctx.translate(-camera.x, -camera.y);

        hazards.forEach(h => {
            if(h.type==='car') {
                if(h.warning>0) { ctx.fillStyle=`rgba(255,0,60,${0.2+Math.sin(t*20)*0.1})`; ctx.fillRect(player.x-1500, h.y-h.h/2, 3000, h.h); ctx.fillStyle='#ff003c'; ctx.font='20px "Share Tech Mono"'; for(let i=-2; i<=2; i++) ctx.fillText(">> TRAFFIC <<", player.x+i*300, h.y+5); }
                else { ctx.shadowBlur=20; ctx.shadowColor='#00f3ff'; ctx.fillStyle='#00f3ff'; ctx.fillRect(h.x,h.y-h.h/2,h.w,h.h); ctx.fillStyle='rgba(0,243,255,0.5)'; ctx.fillRect(h.x-200,h.y-10,200,20); ctx.shadowBlur=0; }
            } else if(h.type==='steam') { ctx.fillStyle=`rgba(200,200,200,${0.1+Math.sin(t+h.x)*0.05})`; ctx.beginPath(); ctx.arc(h.x,h.y,h.radius,0,Math.PI*2); ctx.fill(); }
        });

        // Market Drone
        if (state.market.active) {
            const mx = state.market.x, my = state.market.y;
            // Indicator
            if (getDist(player, state.market) > 600) {
                 const angle = Math.atan2(my - player.y, mx - player.x);
                 const ix = player.x + Math.cos(angle) * 300;
                 const iy = player.y + Math.sin(angle) * 300;
                 ctx.fillStyle = '#00ff00'; ctx.beginPath(); ctx.arc(ix, iy, 10, 0, Math.PI*2); ctx.fill();
            }
            // Drone
            ctx.fillStyle = '#004400'; ctx.beginPath(); ctx.arc(mx, my, 40, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(mx, my, 40, 0, Math.PI*2); ctx.stroke();
            ctx.fillStyle = '#00ff00'; ctx.font='12px "Share Tech Mono"'; ctx.fillText("MARKET", mx-20, my-50);
            // Interaction Circle
            ctx.beginPath(); ctx.arc(mx, my, 60, 0, Math.PI*2); ctx.strokeStyle = 'rgba(0,255,0,0.3)'; ctx.lineWidth=2; ctx.stroke();
            if (state.market.interact > 0) {
                ctx.beginPath(); ctx.arc(mx, my, 60, 0, Math.PI * 2 * (state.market.interact/2)); 
                ctx.strokeStyle = '#00ff00'; ctx.lineWidth=4; ctx.stroke();
            }
        }

        turrets.forEach(t=>{ ctx.shadowBlur=10; ctx.shadowColor='#00ff41'; ctx.fillStyle='#003300'; ctx.beginPath(); ctx.arc(t.x,t.y,15,0,Math.PI*2); ctx.fill(); ctx.save(); ctx.translate(t.x,t.y); ctx.rotate(t.angle); ctx.fillStyle='#00ff41'; ctx.fillRect(-10,-10,20,20); ctx.fillRect(5,-4,15,8); ctx.restore(); ctx.shadowBlur=0; });
        gems.forEach(g=>{ ctx.shadowBlur=10; ctx.shadowColor='#00ff41'; ctx.fillStyle='#00ff41'; ctx.beginPath(); ctx.moveTo(g.x,g.y-5); ctx.lineTo(g.x+5,g.y); ctx.lineTo(g.x,g.y+5); ctx.lineTo(g.x-5,g.y); ctx.fill(); ctx.shadowBlur=0; });
        credits.forEach(c=>{ ctx.shadowBlur=10; ctx.shadowColor='#fcee0a'; ctx.fillStyle='#fcee0a'; ctx.fillRect(c.x-4,c.y-4,8,8); ctx.shadowBlur=0; });

        enemies.forEach(e=>{
            ctx.shadowBlur=10; ctx.shadowColor=e.color; ctx.strokeStyle=e.frozen>0?'#00ffff':e.color; ctx.lineWidth=2;
            ctx.save(); ctx.translate(e.x,e.y); ctx.rotate(e.angle);
            if(e.scale) ctx.scale(e.scale, 2 - e.scale); 
            ctx.globalAlpha = e.alpha !== undefined ? e.alpha : 1.0; 
            if (e.ai === 'barrier') { ctx.beginPath(); ctx.arc(0,0,150,0,Math.PI*2); ctx.strokeStyle = 'cyan'; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]); ctx.fillStyle = 'rgba(0,255,255,0.1)'; ctx.fill(); drawPoly(ctx, 0, 0, e.size, 6, 0, e.color); }
            else if (e.ai === 'shielder') { ctx.fillRect(-10,-10,20,20); ctx.beginPath(); ctx.arc(0,0,25, -Math.PI/3, Math.PI/3); ctx.strokeStyle='orange'; ctx.lineWidth=4; ctx.stroke(); }
            else if (e.shape === 'boss') { drawPoly(ctx, 0, 0, e.size, 5, 0, e.color); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(-15,-10,8,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(15,-10,8,0,Math.PI*2); ctx.fill(); }
            else if (e.shape === 'circle') { ctx.beginPath(); ctx.arc(0,0,e.size,0,Math.PI*2); ctx.stroke(); }
            else if (e.shape === 'rect') { ctx.strokeRect(-e.size/2, -e.size/2, e.size, e.size); }
            else if (e.shape === 'triangle') { drawPoly(ctx, 0, 0, e.size, 3, 0, e.color); }
            else if (e.shape === 'x') { ctx.beginPath(); ctx.moveTo(-e.size,-e.size); ctx.lineTo(e.size,e.size); ctx.moveTo(e.size,-e.size); ctx.lineTo(-e.size,e.size); ctx.stroke(); }
            else if (e.shape === 'cross') { ctx.beginPath(); ctx.moveTo(0,-e.size); ctx.lineTo(0,e.size); ctx.moveTo(-e.size,0); ctx.lineTo(e.size,0); ctx.stroke(); }
            else { drawPoly(ctx, 0, 0, e.size, 4, 0, e.color); }
            if(e.hp<e.maxHp && !e.isBoss) { ctx.fillStyle='#330000'; ctx.fillRect(-15,-e.size-10,30,4); ctx.fillStyle='red'; ctx.fillRect(-15,-e.size-10,30*(e.hp/e.maxHp),4); }
            ctx.globalAlpha = 1.0; ctx.restore(); ctx.shadowBlur=0;
        });

        ctx.shadowBlur=20; ctx.shadowColor=player.color;
        if(player.isDash) { ctx.globalAlpha=0.3; ctx.beginPath(); ctx.arc(player.x-player.vx*0.05, player.y-player.vy*0.05, player.radius, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
        ctx.strokeStyle=player.color; ctx.lineWidth=2;
        ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(t*3); ctx.beginPath(); ctx.arc(0,0,player.radius,0,Math.PI*1.5); ctx.stroke(); ctx.restore();
        ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(player.angle); ctx.fillStyle=player.color; ctx.beginPath(); ctx.moveTo(player.radius+5,0); ctx.lineTo(player.radius-5,-5); ctx.lineTo(player.radius-5,5); ctx.fill(); ctx.restore();
        if(player.shield) { ctx.strokeStyle='cyan'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(player.x,player.y,player.radius+5,0,Math.PI*2); ctx.stroke(); }
        if(player.weapon.type==='monowire') { ctx.strokeStyle='rgba(255,0,60,0.8)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(player.x,player.y,player.weapon.range,0,Math.PI*2); ctx.stroke(); }
        drawPlayerHUD(ctx);
        ctx.shadowBlur=0;

        ctx.globalCompositeOperation='lighter';
        bullets.forEach(b=>{ ctx.fillStyle=b.color; ctx.shadowBlur=10; ctx.shadowColor=b.color; if(b.type==='beam') ctx.fillRect(b.x-20, b.y-2, 40, 4); else { ctx.beginPath(); ctx.arc(b.x,b.y,b.size||2,0,Math.PI*2); ctx.fill(); } ctx.shadowBlur=0; });
        ctx.globalCompositeOperation='source-over';
        particles.forEach(p=>{ if(p.type==='lightning') { ctx.strokeStyle=p.color; ctx.lineWidth=2; ctx.shadowBlur=10; ctx.shadowColor=p.color; ctx.beginPath(); if(p.chain.length){ctx.moveTo(player.x,player.y); p.chain.forEach(pt=>ctx.lineTo(pt.x,pt.y));} ctx.stroke(); ctx.shadowBlur=0; } else if(p.type==='shockwave') { ctx.strokeStyle=p.color; const pr=1-(p.life/0.5); ctx.lineWidth=5*(1-pr); ctx.beginPath(); ctx.arc(p.x,p.y,p.maxRadius*pr,0,Math.PI*2); ctx.stroke(); ctx.fillStyle=p.color; ctx.globalAlpha=0.2*(1-pr); ctx.fill(); ctx.globalAlpha=1; } else { ctx.fillStyle=p.color; ctx.globalAlpha=p.life*2>1?1:p.life*2; ctx.fillRect(p.x,p.y,p.size,p.size); ctx.globalAlpha=1; } });
        texts.forEach(d=>{ ctx.shadowBlur=5; ctx.shadowColor=d.color; ctx.fillStyle=d.color; ctx.font=`bold ${d.size}px "Share Tech Mono"`; ctx.fillText(d.text,d.x,d.y); ctx.shadowBlur=0; });
        ctx.restore();
        renderMinimap();
        updateUIElements();
    }

    function drawPlayerHUD(ctx) {
        const x = player.x; const y = player.y; const r = player.radius + 20; const w = player.weapon;
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.strokeStyle = 'rgba(50, 50, 50, 0.5)'; ctx.lineWidth = 3; ctx.stroke();
        const heatPct = w.heat / (w.maxHeat * (player.stats.heatCapMulti || 1));
        ctx.beginPath(); ctx.arc(x, y, r, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * heatPct)); ctx.strokeStyle = w.isOverheated ? '#ff003c' : (heatPct > 0.8 ? '#ff8800' : '#fcee0a'); ctx.lineWidth = 3; ctx.stroke();
        if (w.isVenting) {
            const startAngle = -Math.PI/2 + (Math.PI * 2 * w.sweetSpotStart); const endAngle = startAngle + (Math.PI * 2 * w.sweetSpotWidth); const cursorAngle = -Math.PI/2 + (Math.PI * 2 * w.ventProgress);
            ctx.beginPath(); ctx.arc(x, y, r + 6, startAngle, endAngle); ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 5; ctx.stroke();
            ctx.beginPath(); ctx.arc(x, y, r + 6, cursorAngle - 0.1, cursorAngle + 0.1); ctx.strokeStyle = '#ff003c'; ctx.lineWidth = 5; ctx.stroke();
        }
        if (w.isOverheated) { ctx.fillStyle = '#ff003c'; ctx.font = '10px "Share Tech Mono"'; ctx.textAlign = 'center'; ctx.fillText("OVERHEAT", x, y - r - 8); }
    }

    function drawGrid(ctx, biome, t) {
        const sz=80, ox=Math.floor(camera.x)%sz, oy=Math.floor(camera.y)%sz;
        ctx.strokeStyle=biome.grid; ctx.lineWidth=2; ctx.beginPath();
        for(let x=-ox; x<state.width; x+=sz) { ctx.moveTo(x,0); ctx.lineTo(x,state.height); }
        for(let y=-oy; y<state.height; y+=sz) { const s=(Math.sin(y/100+t*2)+1)*0.5; ctx.lineWidth=1+s*2; ctx.strokeStyle=`rgba(0,243,255,${0.1+s*0.1})`; ctx.moveTo(0,y); ctx.lineTo(state.width,y); }
        ctx.stroke();
    }
    
    function drawPoly(ctx, x, y, r, s, a, c) {
        ctx.beginPath(); for(let i=0; i<s; i++) { const th=a+i*2*Math.PI/s; i===0?ctx.moveTo(x+Math.cos(th)*r, y+Math.sin(th)*r):ctx.lineTo(x+Math.cos(th)*r, y+Math.sin(th)*r); } ctx.closePath(); ctx.strokeStyle=c; ctx.lineWidth=2; ctx.stroke(); ctx.fillStyle=c; ctx.globalAlpha=0.2; ctx.fill(); ctx.globalAlpha=1;
    }

    function renderMinimap() {
        mmCtx.fillStyle='rgba(0,10,0,0.9)'; mmCtx.fillRect(0,0,160,160);
        const cx=80, cy=80, range=2000, scl=80/range;
        mmCtx.strokeStyle='rgba(0,255,0,0.2)'; mmCtx.beginPath(); mmCtx.arc(cx,cy,48,0,Math.PI*2); mmCtx.stroke();
        enemies.forEach(e=>{ const d=getDist(e,player); if(d<range) { mmCtx.fillStyle=e.isBoss?'#ff0000':'#ff003c'; mmCtx.beginPath(); mmCtx.arc(cx+(e.x-player.x)*scl, cy+(e.y-player.y)*scl, e.isBoss?4:2, 0, Math.PI*2); mmCtx.fill(); }});
        mmCtx.fillStyle='#00ff41'; gems.forEach(g=>{ if(getDist(g,player)<range) mmCtx.fillRect(cx+(g.x-player.x)*scl, cy+(g.y-player.y)*scl, 1.5, 1.5); });
        mmCtx.save(); mmCtx.translate(cx,cy); mmCtx.rotate(player.angle); mmCtx.fillStyle='#fff'; mmCtx.beginPath(); mmCtx.moveTo(4,0); mmCtx.lineTo(-3,-3); mmCtx.lineTo(-3,3); mmCtx.fill(); mmCtx.restore();
    }

    function updateUIElements() {
        const m=Math.floor(state.timeElapsed/60), s=Math.floor(state.timeElapsed%60).toString().padStart(2,'0');
        document.getElementById('timer').innerText=`${m}:${s}`;
        document.getElementById('kill-count').innerText=state.kills;
        document.getElementById('level').innerText=state.level;
        document.getElementById('hp-bar-fill').style.width=Math.max(0,player.hp/player.maxHp*100)+'%';
        document.getElementById('hp-text').innerText=`${Math.ceil(player.hp)}/${Math.ceil(player.maxHp)}`;
        document.getElementById('humanity-bar-fill').style.width=Math.max(0,player.humanity)+'%';
        const xpPct = Math.min(100, (state.xp / state.nextLevelXp) * 100);
        document.getElementById('xp-bar-fill').style.width = xpPct + '%';
        document.getElementById('shield-bar-fill').style.width = player.shield ? '100%' : Math.max(0, (player.stats.shieldCharge||0)/500*100)+'%';
        const hStat=document.getElementById('humanity-status');
        if(player.humanity<20) { hStat.innerText="CYBERPSYCHOSIS"; hStat.style.color="var(--neon-red)"; hStat.classList.add("glitched-text"); }
        else { hStat.innerText=player.humanity<50?"UNSTABLE":"STABLE"; hStat.style.color=player.humanity<50?"var(--neon-yellow)":"var(--neon-blue)"; hStat.classList.remove("glitched-text"); }
        const cdPct = Math.max(0, (player.skillCd/player.maxSkillCd)*100);
        document.getElementById('skill-cd-overlay').style.height = cdPct+'%';
        const sBox = document.getElementById('skill-box');
        if(player.skillCd<=0) { sBox.classList.add('ready'); document.getElementById('skill-timer').innerText="READY"; document.getElementById('skill-timer').style.color="var(--neon-green)"; }
        else { sBox.classList.remove('ready'); document.getElementById('skill-timer').innerText=player.skillCd.toFixed(1); document.getElementById('skill-timer').style.color="#888"; }
        if(state.bossActive && boss) document.getElementById('boss-bar-fill').style.width=(boss.hp/boss.maxHp*100)+'%';
    }

    function createExplosion(x,y,c,col) { for(let i=0;i<c;i++) particles.push({x:x,y:y,vx:(Math.random()-0.5)*200,vy:(Math.random()-0.5)*200,life:0.4+Math.random()*0.4,color:col,size:Math.random()*3+1}); }
    function createShockwave(x,y,col,rad) { particles.push({x:x,y:y,vx:0,vy:0,life:0.5,color:col,size:10,type:'shockwave',maxRadius:rad}); }
    function showText(t,x,y,c,s=16) { texts.push({text:t,x:x,y:y,color:c,life:1,size:s}); }
    function gameOver() { state.isRunning=false; document.getElementById('final-time').innerText=document.getElementById('timer').innerText; document.getElementById('final-kills').innerText=state.kills; document.getElementById('gameover-screen').classList.remove('hidden'); }
    function playSound(t) { if(audioCtx.state==='suspended')audioCtx.resume(); const o=audioCtx.createOscillator(),g=audioCtx.createGain(),now=audioCtx.currentTime; o.connect(g); g.connect(audioCtx.destination); if(t==='shoot'){o.frequency.setValueAtTime(200,now);o.frequency.exponentialRampToValueAtTime(50,now+0.1);g.gain.setValueAtTime(0.05,now);g.gain.linearRampToValueAtTime(0,now+0.1);o.start(now);o.stop(now+0.1);} else if(t==='hit'){o.type='sawtooth';o.frequency.setValueAtTime(100,now);g.gain.setValueAtTime(0.05,now);g.gain.linearRampToValueAtTime(0,now+0.1);o.start(now);o.stop(now+0.1);} else if(t==='powerup'){o.frequency.setValueAtTime(400,now);o.frequency.linearRampToValueAtTime(800,now+0.3);g.gain.setValueAtTime(0.05,now);g.gain.linearRampToValueAtTime(0,now+0.3);o.start(now);o.stop(now+0.3);} else if(t==='jam'){o.type='square';o.frequency.setValueAtTime(100,now);g.gain.setValueAtTime(0.05,now);g.gain.linearRampToValueAtTime(0,now+0.2);o.start(now);o.stop(now+0.2);} else if(t==='overheat'){o.type='triangle';o.frequency.setValueAtTime(300,now);o.frequency.linearRampToValueAtTime(100,now+0.5);g.gain.setValueAtTime(0.1,now);g.gain.linearRampToValueAtTime(0,now+0.5);o.start(now);o.stop(now+0.5);} }

    function gameLoop(t) { if(!state.isRunning)return; const dt=(t-state.lastTime)/1000; state.lastTime=t; if(!state.paused){state.timeElapsed+=dt; state.globalTime+=dt; update(dt); render();} requestAnimationFrame(gameLoop); }
    
    initUI();
</script>
</body>
</html>
